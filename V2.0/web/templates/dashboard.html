{% extends "base.html" %}

{% block title %}Dashboard - 3D Scanner Control{% endblock %}

{% block head %}
<style>
    .camera-controls-panel {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border: 1px solid #dee2e6;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .control-group {
        background: white;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid #e9ecef;
    }
    
    .control-group label {
        color: #495057;
        font-weight: 600;
        font-size: 0.8rem;
    }
    
    .btn {
        padding: 3px 6px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7rem;
        transition: all 0.2s;
    }
    
    .btn-primary {
        background: #007bff;
        color: white;
    }
    
    .btn-primary:hover {
        background: #0056b3;
    }
    
    .btn-secondary {
        background: #6c757d;
        color: white;
    }
    
    .btn-secondary:hover {
        background: #545b62;
    }
    
    .btn-sm {
        padding: 2px 4px;
        font-size: 0.65rem;
    }
    
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: #ddd;
        border-radius: 3px;
        outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
    }
    
    .status-info { color: #17a2b8; }
    .status-success { color: #28a745; }
    .status-error { color: #dc3545; }
    
    .action-btn.emergency {
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: white;
        border: 2px solid #b21f2d;
        font-weight: bold;
        animation: pulse-emergency 2s infinite;
    }
    
    .action-btn.emergency:hover {
        background: linear-gradient(135deg, #c82333, #a71e2a);
        transform: scale(1.05);
    }
    
    @keyframes pulse-emergency {
        0%, 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4); }
        50% { box-shadow: 0 0 0 8px rgba(220, 53, 69, 0); }
    }
    
    /* Responsive Dashboard Grid */
    .dashboard-grid {
        display: grid;
        grid-template-columns: minmax(180px, 200px) minmax(180px, 200px) minmax(300px, 1fr) minmax(300px, 1fr);
        grid-template-rows: minmax(600px, 1fr) auto;  /* Increase first row height, activity log auto-sized */
        gap: 0.75rem;
        margin-bottom: 0.75rem;
        width: 100%;
        align-items: stretch;
    }
    
    /* Force all first-row panels to have the same height by making them grid items in row 1 */
    .dashboard-grid > section {
        display: flex;
        flex-direction: column;
    }
    
    /* Make all panels in first row match height - they share grid row 1 */
    .status-panel,
    .actions-panel,
    .reserved-panel,
    .camera-panel {
        align-self: stretch;  /* Stretch vertically within the grid cell */
    }
    
    .status-panel .status-grid,
    .actions-panel .action-grid {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    /* Ensure main content allows horizontal scrolling on smaller screens */
    .main-content {
        flex: 1;
        padding: 0.5rem;
        width: 100%;
        max-width: none;
        margin: 0;
        overflow-x: auto;
        overflow-y: auto;
    }
    
    /* Responsive breakpoints */
    @media screen and (max-width: 1400px) {
        .dashboard-grid {
            grid-template-columns: 180px 180px 1fr 1fr;
            min-width: 1200px; /* Force horizontal scroll on smaller screens */
        }
    }
    
    @media screen and (max-width: 1200px) {
        .dashboard-grid {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            min-width: auto;
        }
        
        .status-panel {
            grid-column: 1 / 2 !important;
            grid-row: 1 / 2 !important;
        }
        
        .actions-panel {
            grid-column: 2 / 3 !important;
            grid-row: 1 / 2 !important;
        }
        
        .reserved-panel {
            grid-column: 1 / 2 !important;
            grid-row: 2 / 3 !important;
        }
        
        .camera-panel {
            grid-column: 2 / 3 !important;
            grid-row: 2 / 3 !important;
        }
        
        .log-panel {
            grid-column: 1 / 3 !important;
            grid-row: 3 / 4 !important;
        }
    }
</style>
{% endblock %}

{% block content %}
<main class="main-content">
<div class="dashboard-grid">
    <!-- Column 1: System Status Panel (Thin) -->
    <section class="status-panel" style="grid-row: 1 / 2; grid-column: 1 / 2; background: #f8f9fa; padding: 0.75rem; border-radius: 8px; border: 1px solid #dee2e6; min-height: 500px;">
        <h2 style="font-size: 1rem; margin-bottom: 0.5rem; margin-top: 0;">System Status</h2>
        <div class="status-grid" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Motion Controller</span>
                    <span class="status-indicator" id="motionStatus" style="font-size: 0.9rem;">●</span>
                </div>
                <div class="status-details" id="motionDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Connection: <span id="motionConnection" class="status-value">Unknown</span></div>
                    <div>Homed: <span id="motionHomed" class="status-value">Unknown</span></div>
                    <div style="font-size: 0.65rem;">Position: 
                        <div style="margin-left: 0.3rem;">
                            X:<span id="currentX">0.0</span>mm
                            Y:<span id="currentY">0.0</span>mm
                        </div>
                        <div style="margin-left: 0.3rem;">
                            Z:<span id="currentZ">0.0</span>°
                            C:<span id="currentC">0.0</span>°
                        </div>
                    </div>
                    <div>State: <span id="motionState">Unknown</span></div>
                    <div>Activity: <span id="motionActivity" class="status-value">Unknown</span></div>
                    <div>FluidNC: <span id="fluidncStatus" class="status-value">Unknown</span></div>
                </div>
            </div>

            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Cameras</span>
                    <span class="status-indicator" id="cameraStatus" style="font-size: 0.9rem;">●</span>
                </div>
                <div class="status-details" id="cameraDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Available: <span id="cameraCount">0</span></div>
                    <div>Active: <span id="activeCameras">None</span></div>
                    <div>State: <span id="cameraState">Unknown</span></div>
                </div>
            </div>

            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Lighting</span>
                    <span class="status-indicator" id="lightingStatus" style="font-size: 0.9rem;">●</span>
                </div>
                <div class="status-details" id="lightingDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Zones: <span id="lightingZones">0</span></div>
                    <div>Status: <span id="lightingState">Unknown</span></div>
                </div>
            </div>

            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Current Scan</span>
                    <span class="status-indicator" id="scanStatus" style="font-size: 0.9rem;">●</span>
                </div>
                <div class="status-details" id="scanDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Progress: <span id="scanProgress">---%</span></div>
                    <div>Points: <span id="scanPoints">0/0</span></div>
                    <div>Phase: <span id="scanPhase">Idle</span></div>
                    <div>State: <span id="scanState">Unknown</span></div>
                </div>
            </div>
        </div>
    </section>

    <!-- Column 2: Quick Actions Panel (Thin) -->
    <section class="actions-panel" style="grid-row: 1 / 2; grid-column: 2 / 3; background: #f8f9fa; padding: 0.75rem; border-radius: 8px; border: 1px solid #dee2e6; min-height: 500px;">
        <h2 style="font-size: 1rem; margin-bottom: 0.5rem; margin-top: 0;">Quick Actions</h2>
        <div class="action-grid" style="display: flex; flex-direction: column; gap: 0.4rem;">
            <button class="action-btn primary" onclick="homeAllAxes()" id="homeAllBtn" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: linear-gradient(135deg, #007bff, #0056b3); color: white; font-weight: 600; transition: all 0.2s;">
                🏠 Home All
            </button>
            <button class="action-btn secondary" onclick="capturePhoto()" id="captureBtn" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #6c757d; color: white; transition: all 0.2s;">
                📸 Capture Photo
            </button>
            <button class="action-btn secondary" onclick="testLighting()" id="lightTestBtn" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #6c757d; color: white; transition: all 0.2s;">
                ⚡ Test Lighting
            </button>
            <button class="action-btn secondary" onclick="testNotifications()" id="testNotifyBtn" title="Test notification stacking" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #6c757d; color: white; transition: all 0.2s;">
                🔔 Test Alerts
            </button>
            <button class="action-btn emergency" onclick="cancelAllScans()" id="cancelAllBtn" title="Emergency: Stop all scanning operations" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: 2px solid #b21f2d; cursor: pointer; font-weight: bold;">
                🛑 Cancel All Scans
            </button>
            <button class="action-btn tertiary" onclick="window.location.href='/manual'" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #17a2b8; color: white; transition: all 0.2s;">
                🎮 Manual Control
            </button>
            <button class="action-btn tertiary" onclick="window.location.href='/scans'" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #17a2b8; color: white; transition: all 0.2s;">
                📊 Start Scan
            </button>
            <button class="action-btn tertiary" onclick="refreshStatus()" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #17a2b8; color: white; transition: all 0.2s;">
                🔄 Refresh Status
            </button>
        </div>
    </section>

    <!-- Column 3: Reserved Space (Wider) -->
    <section class="reserved-panel" style="grid-row: 1 / 2; grid-column: 3 / 4; background: #ffffff; border: 1px solid #e2e8f0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); display: flex; flex-direction: column; min-height: 500px; height: 100%; position: relative; overflow: hidden; border-radius: 12px; padding: 1rem;">
        <!-- Header with Position and Progress Info -->
        <div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
            <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: 1rem;">
                <!-- Title Section -->
                <div style="flex-shrink: 0;">
                    <h2 style="font-size: 1.1rem; margin: 0; color: #1e293b; font-weight: 700; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.3rem;">📊</span>
                        Real-Time Position Monitor
                    </h2>
                    <p id="viz-mode-indicator" style="font-size: 0.8rem; margin: 0.35rem 0 0 0; color: #64748b; font-weight: 500;">📍 Idle - Live Position</p>
                </div>
                
                <!-- Position and Progress Side-by-Side -->
                <div style="display: flex; gap: 1.5rem; align-items: flex-start; flex: 1;">
                    <div style="display: flex; flex-direction: column; gap: 0.25rem; min-width: 0;">
                        <strong style="color: #1e293b; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em;">📍 Position</strong>
                        <span id="viz-current-pos" style="font-family: 'Courier New', monospace; color: #3b82f6; font-size: 0.8rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">--</span>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 0.25rem; min-width: 0;">
                        <strong style="color: #1e293b; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em;">📈 Progress</strong>
                        <span id="viz-scan-progress" style="font-family: 'Courier New', monospace; color: #10b981; font-size: 0.8rem; font-weight: 600; white-space: nowrap;">--</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 3D Visualization Canvas -->
        <div id="dashboard-3d-plot" style="flex: 1; width: 100%; height: 100%; min-height: 400px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);"></div>
    </section>

    <!-- Column 4: Live Camera Feed (Wider) -->
    <section class="camera-panel" style="grid-row: 1 / 2; grid-column: 4 / 5; background: #f8f9fa; padding: 0.75rem; border-radius: 8px; border: 1px solid #dee2e6; min-height: 500px;">
        <h2 style="font-size: 1rem; margin-bottom: 0.5rem; margin-top: 0;">Live Camera Feed</h2>
        <div class="camera-grid">
            <div class="camera-container">
                <h3 style="font-size: 0.85rem; margin-bottom: 0.4rem;">Camera 0 - Native 1080p Stream</h3>
                <div class="camera-feed-wrapper" style="position: relative;">
                    <img id="camera0Feed" 
                         src="/camera/0?t=0" 
                         alt="Camera 0 - 1080p Stream" 
                         class="camera-feed"
                         onload="cameraStreamWorking = true; console.log('Camera 0 native 1080p stream loaded');"
                         onerror="console.log('Camera 0 stream error, retrying...'); setTimeout(() => { const timestamp = Date.now(); this.src = '/camera/0?t=' + timestamp; }, 2000);">
                    <div class="camera-overlay" style="position: absolute; bottom: 10px; right: 10px; display: flex; gap: 0.5rem; z-index: 10;">
                        <button class="camera-control modern-btn capture-btn" onclick="captureFromCamera(0)" title="Capture High-Resolution Photo" style="padding: 0.4rem 0.6rem; font-size: 0.7rem; border-radius: 6px; border: none; background: #007bff; color: white; cursor: pointer;">
                            <span class="btn-icon">📸</span>
                            <span class="btn-text">Capture</span>
                        </button>
                        <button class="camera-control modern-btn refresh-btn" onclick="manualRefreshCamera()" title="Refresh Camera Stream" style="padding: 0.4rem 0.6rem; font-size: 0.7rem; border-radius: 6px; border: none; background: #6c757d; color: white; cursor: pointer;">
                            <span class="btn-icon">🔄</span>
                            <span class="btn-text">Refresh</span>
                        </button>
                    </div>
                </div>
                <div class="camera-info" style="margin-top: 0.3rem;">
                    <small style="font-size: 0.7rem; color: #6c757d;">🎥 Live 1080p stream • 📸 High-res capture available during scanning</small>
                </div>
                
                <!-- Camera Controls - Compact -->
                <div class="camera-controls-panel" style="margin-top: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                    <h4 style="font-size: 0.85rem; margin-bottom: 0.4rem;">Camera Controls</h4>
                    <div class="controls-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem;">
                        <!-- Focus Controls -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">Focus Control</label>
                            <div style="display: flex; gap: 0.2rem; margin-bottom: 0.4rem;">
                                <button class="btn btn-sm btn-primary" onclick="triggerAutofocus()" style="padding: 0.2rem 0.3rem; font-size: 0.65rem;">🎯 Auto</button>
                                <button class="btn btn-sm btn-secondary" onclick="toggleManualFocus()" style="padding: 0.2rem 0.3rem; font-size: 0.65rem;">⚙️ Manual</button>
                                <button id="stabilizeBtn" class="btn btn-sm btn-warning" onclick="toggleStabilization()" style="padding: 0.2rem 0.3rem; font-size: 0.65rem;">🔧 Stab</button>
                            </div>
                            <div id="manualFocusPanel" style="display: none;">
                                <label for="focusSlider" style="font-size: 0.65rem;">Focus Position (0=Near, 10=Far)</label>
                                <input type="range" id="focusSlider" min="0" max="10" step="0.1" value="5" 
                                       style="width: 100%;" onchange="setManualFocus(this.value)">
                                <span id="focusValue" style="font-size: 0.65rem;">5.0</span>
                            </div>
                        </div>
                        
                        <!-- Exposure Controls -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">Exposure Control</label>
                            <div style="margin-bottom: 0.4rem;">
                                <label style="display: flex; align-items: center; font-size: 0.7rem;">
                                    <input type="checkbox" id="autoExposure" checked onchange="toggleAutoExposure(this.checked)">
                                    <span style="margin-left: 0.3rem;">Auto Exposure</span>
                                </label>
                            </div>
                            <div id="manualExposurePanel" style="display: none;">
                                <label for="exposureSlider" style="font-size: 0.65rem;">Exposure Time (ms)</label>
                                <input type="range" id="exposureSlider" min="1" max="100" value="10" 
                                       style="width: 100%;" onchange="setExposureTime(this.value)">
                                <span id="exposureValue" style="font-size: 0.65rem;">10ms</span>
                            </div>
                        </div>
                        
                        <!-- ISO Controls -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label for="isoSlider" style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">ISO Setting</label>
                            <input type="range" id="isoSlider" min="100" max="1600" step="100" value="400" 
                                   style="width: 100%;" onchange="setISO(this.value)">
                            <span id="isoValue" style="font-size: 0.65rem;">ISO 400</span>
                        </div>
                        
                        <!-- White Balance -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">White Balance</label>
                            <div style="margin-bottom: 0.3rem;">
                                <label style="display: flex; align-items: center; font-size: 0.7rem;">
                                    <input type="checkbox" id="autoWhiteBalance" checked onchange="toggleAutoWhiteBalance(this.checked)">
                                    <span style="margin-left: 0.3rem;">Auto White Balance</span>
                                </label>
                            </div>
                            <div id="manualWhiteBalancePanel" style="display: none;">
                                <label style="font-size: 0.65rem; display: block; margin-bottom: 0.2rem;">White Balance Mode</label>
                                <select id="whiteBalanceMode" style="width: 100%; padding: 0.2rem; margin-bottom: 0.3rem; font-size: 0.65rem;" onchange="setWhiteBalanceMode(this.value)">
                                    <option value="indoor">🏠 Indoor</option>
                                    <option value="daylight">☀️ Daylight</option>
                                    <option value="tungsten">💡 Tungsten</option>
                                </select>
                                <button class="btn btn-sm btn-success" onclick="lockWhiteBalance()" style="width: 100%; padding: 0.2rem; font-size: 0.65rem;">
                                    🔒 Lock Current WB
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Status Display -->
                    <div id="controlsStatus" style="margin-top: 0.4rem; padding: 0.3rem; background: #e9ecef; border-radius: 4px; font-size: 0.65rem; text-align: center;">
                        Status: Ready
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Activity Log Panel - Full Width Bottom (spans all 4 columns) -->
    <section class="log-panel" style="grid-column: 1 / 5; grid-row: 2 / 3;">
        <h2 style="font-size: 0.85rem; margin-bottom: 0.4rem;">Activity Log</h2>
        <div class="log-container" style="max-height: 80px; background: white; padding: 0.4rem; border-radius: 6px; border: 1px solid #e9ecef;">
            <div id="activityLog" class="log-content" style="font-size: 0.7rem; max-height: 60px; overflow-y: auto;">
                <div class="log-entry info">
                    <span class="log-timestamp">{{ status.timestamp[:19] if status.timestamp else '--:--:--' }}</span>
                    <span class="log-message">Web interface initialized</span>
                </div>
            </div>
            <div class="log-controls" style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                <button onclick="clearLog()" class="log-control-btn" style="padding: 0.2rem 0.5rem; font-size: 0.7rem; border-radius: 4px; border: 1px solid #6c757d; background: white; cursor: pointer;">Clear</button>
                <button onclick="downloadLog()" class="log-control-btn" style="padding: 0.2rem 0.5rem; font-size: 0.7rem; border-radius: 4px; border: 1px solid #6c757d; background: white; cursor: pointer;">Download</button>
                <label class="log-control-checkbox" style="font-size: 0.7rem; display: flex; align-items: center; gap: 0.3rem;">
                    <input type="checkbox" id="autoScroll" checked>
                    Auto-scroll
                </label>
            </div>
        </div>
    </section>
</div>
</main>

    <script>
        // High-performance camera stream management
        let cameraStreamWorking = false;
        let refreshInterval = null;
        let streamCheckInterval = null;
        
        function startCameraRefresh() {
            // Initial load only - no automatic refresh
            refreshCameraStream();
            
            // Only monitor stream health for error recovery
            streamCheckInterval = setInterval(checkStreamHealth, 5000);  // Every 5 seconds
        }
        
        function refreshCameraStream() {
            const camera0Feed = document.getElementById('camera0Feed');
            if (camera0Feed) {
                const timestamp = Date.now();
                console.log('Refreshing Camera 0 stream...');
                camera0Feed.src = '/camera/0?t=' + timestamp;
            }
        }
        
        function checkStreamHealth() {
            const camera0Feed = document.getElementById('camera0Feed');
            if (camera0Feed && !cameraStreamWorking) {
                console.log('Camera stream health check failed - refreshing for error recovery...');
                refreshCameraStream();
            }
            // Reset flag for next check
            cameraStreamWorking = false;
        }
        
        function manualRefreshCamera() {
            console.log('Manual camera refresh requested by user');
            refreshCameraStream();
        }
        
        function stopCameraRefresh() {
            // Only need to stop health check interval (no automatic refresh anymore)
            if (streamCheckInterval) {
                clearInterval(streamCheckInterval);
                streamCheckInterval = null;
            }
        }
        
        // Stop refresh when page unloads
        window.addEventListener('beforeunload', stopCameraRefresh);
        
        // Camera Control Functions
        async function triggerAutofocus() {
            try {
                updateControlsStatus('Triggering autofocus...', 'info');
                
                const response = await fetch('/api/camera/autofocus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ camera_id: 'camera_1' })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus('Autofocus triggered successfully', 'success');
                } else {
                    updateControlsStatus('Autofocus failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Autofocus error: ' + error.message, 'error');
                console.error('Autofocus error:', error);
            }
        }
        
        function toggleManualFocus() {
            const panel = document.getElementById('manualFocusPanel');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Disable autofocus when switching to manual
                setCameraControls({ autofocus: false });
            }
        }
        
        async function setManualFocus(position) {
            try {
                document.getElementById('focusValue').textContent = parseFloat(position).toFixed(1);
                
                const response = await fetch('/api/camera/focus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        focus_position: parseFloat(position)
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus(`Manual focus set to ${position}`, 'success');
                } else {
                    updateControlsStatus('Focus setting failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Focus setting error: ' + error.message, 'error');
                console.error('Manual focus error:', error);
            }
        }
        
        let stabilizationEnabled = false;
        async function toggleStabilization() {
            try {
                stabilizationEnabled = !stabilizationEnabled;
                const btn = document.getElementById('stabilizeBtn');
                
                const response = await fetch('/api/camera/stabilize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        enable: stabilizationEnabled
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    btn.textContent = stabilizationEnabled ? '🔒 Stabilized' : '🔧 Stabilize';
                    btn.className = stabilizationEnabled ? 'btn btn-sm btn-success' : 'btn btn-sm btn-warning';
                    updateControlsStatus(stabilizationEnabled ? 'Camera stabilization enabled' : 'Camera stabilization disabled', 'info');
                } else {
                    updateControlsStatus('Stabilization toggle failed: ' + (result.error || 'Unknown error'), 'error');
                    stabilizationEnabled = !stabilizationEnabled; // Revert on failure
                }
            } catch (error) {
                updateControlsStatus('Stabilization error: ' + error.message, 'error');
                console.error('Stabilization error:', error);
                stabilizationEnabled = !stabilizationEnabled; // Revert on failure
            }
        }
        
        function toggleAutoExposure(enabled) {
            const panel = document.getElementById('manualExposurePanel');
            panel.style.display = enabled ? 'none' : 'block';
            setCameraControls({ auto_exposure: enabled });
        }
        
        function setExposureTime(timeMs) {
            document.getElementById('exposureValue').textContent = timeMs + 'ms';
            setCameraControls({ 
                auto_exposure: false,
                exposure_time: parseInt(timeMs)
            });
        }
        
        function setISO(isoValue) {
            document.getElementById('isoValue').textContent = 'ISO ' + isoValue;
            setCameraControls({ iso: parseInt(isoValue) });
        }
        
        function toggleAutoWhiteBalance(enabled) {
            const panel = document.getElementById('manualWhiteBalancePanel');
            panel.style.display = enabled ? 'none' : 'block';
            setWhiteBalanceMode(enabled ? 'auto' : 'indoor');
        }
        
        async function setWhiteBalanceMode(mode) {
            try {
                const response = await fetch('/api/camera/white_balance', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        mode: mode
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus(`White balance set to ${mode}`, 'success');
                } else {
                    updateControlsStatus('White balance setting failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('White balance error: ' + error.message, 'error');
                console.error('White balance error:', error);
            }
        }
        
        async function lockWhiteBalance() {
            const mode = document.getElementById('whiteBalanceMode').value;
            await setWhiteBalanceMode(mode);
            updateControlsStatus(`White balance locked to ${mode} mode`, 'info');
        }
        
        function toggleAutoWhiteBalance(enabled) {
            setCameraControls({ auto_white_balance: enabled });
        }
        
        async function setCameraControls(controls) {
            try {
                updateControlsStatus('Applying camera settings...', 'info');
                
                const response = await fetch('/api/camera/controls', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        controls: controls
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus('Settings applied successfully', 'success');
                } else {
                    updateControlsStatus('Settings failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Settings error: ' + error.message, 'error');
                console.error('Camera controls error:', error);
            }
        }
        
        function updateControlsStatus(message, type) {
            const statusElement = document.getElementById('controlsStatus');
            if (statusElement) {
                statusElement.textContent = 'Status: ' + message;
                statusElement.className = 'status-' + type;
                
                // Clear status after 3 seconds for non-error messages
                if (type !== 'error') {
                    setTimeout(() => {
                        statusElement.textContent = 'Status: Ready';
                        statusElement.className = '';
                    }, 3000);
                }
            }
        }
        
        // Motion Control Functions
        // Notification system - now uses the improved ScannerBase alert system
        function showNotification(message, type = 'info') {
            // Use the new ScannerBase alert system which properly handles positioning and stacking
            ScannerBase.showAlert(message, type, 5000, false);
        }

        // Test notification system to demonstrate proper stacking and positioning
        function testNotifications() {
            const messages = [
                { msg: 'Test success notification', type: 'success' },
                { msg: 'Test warning notification', type: 'warning' },
                { msg: 'Test error notification', type: 'error' },
                { msg: 'Test info notification', type: 'info' }
            ];
            
            messages.forEach((notification, index) => {
                setTimeout(() => {
                    showNotification(notification.msg, notification.type);
                }, index * 500); // Stagger by 500ms each
            });
        }

        // Emergency function to cancel all scanning operations
        async function cancelAllScans() {
            try {
                console.log('Emergency: Canceling all scans...');
                
                // Disable button temporarily
                const cancelButton = document.getElementById('cancelAllBtn');
                if (cancelButton) {
                    cancelButton.disabled = true;
                    cancelButton.textContent = '🔄 Canceling...';
                }
                
                showNotification('Emergency: Stopping all scans...', 'warning');
                
                // Call the scan stop API
                const response = await fetch('/api/scan/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('All scans stopped successfully');
                        showNotification('All scanning operations stopped', 'success');
                    } else {
                        console.warn('Stop command sent but result unclear:', result);
                        showNotification('Stop command sent - check scan status', 'warning');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Cancel API error:', response.status, errorText);
                    showNotification(`Cancel failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Cancel all scans error:', error);
                showNotification('Cancel error: ' + error.message, 'error');
            } finally {
                // Re-enable button
                const cancelButton = document.getElementById('cancelAllBtn');
                if (cancelButton) {
                    cancelButton.disabled = false;
                    cancelButton.textContent = '🛑 Cancel All Scans';
                }
                
                // Refresh status to show updated state
                refreshStatus();
            }
        }

        async function homeAllAxes() {
            try {
                console.log('Starting homing sequence...');
                
                // Disable button during homing
                const homeButton = document.getElementById('homeAllBtn');
                if (homeButton) {
                    homeButton.disabled = true;
                    homeButton.textContent = 'Homing...';
                }
                
                showNotification('Starting homing sequence...', 'info');
                
                const response = await fetch('/api/home', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ axes: ['X', 'Y', 'Z', 'C'] })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Homing API response:', result); // Debug logging
                    
                    if (result.success && result.data && result.data.status === 'in_progress') {
                        console.log('Homing started, will listen for completion via status updates');
                        showNotification('Homing in progress...', 'warning');
                        
                        // Use existing status update system instead of separate polling
                        let homingStartTime = Date.now();
                        let homingTimeout = null;
                        let isWaitingForHoming = true;
                        
                        // Set a maximum timeout (4 minutes)
                        homingTimeout = setTimeout(() => {
                            if (isWaitingForHoming) {
                                isWaitingForHoming = false;
                                console.log('Homing timeout - no completion detected');
                                showNotification('Homing timeout - check system status', 'error');
                                if (homeButton) {
                                    homeButton.disabled = false;
                                    homeButton.textContent = '🏠 Home All';
                                }
                            }
                        }, 240000); // 4 minutes
                        
                        // Listen for the next status update that shows homing complete
                        const homingCompleteHandler = (event) => {
                            if (!isWaitingForHoming) return;
                            
                            const status = event.detail.status;
                            if (status.motion && (status.motion.homed === true || status.motion.is_homed === true)) {
                                isWaitingForHoming = false;
                                clearTimeout(homingTimeout);
                                document.removeEventListener('scanner:statusUpdate', homingCompleteHandler);
                                
                                const elapsed = Math.round((Date.now() - homingStartTime) / 1000);
                                console.log(`✅ Homing completed in ${elapsed}s via status update!`);
                                showNotification(`All axes homed successfully! (${elapsed}s)`, 'success');
                                
                                if (homeButton) {
                                    homeButton.disabled = false;
                                    homeButton.textContent = '🏠 Home All';
                                }
                            } else {
                                // Progress tracking is handled by dashboard.js, no need for duplicate messages
                            }
                        };
                        
                        // Listen for status updates instead of polling
                        document.addEventListener('scanner:statusUpdate', homingCompleteHandler);
                        
                    } else {
                        console.error('Homing failed. Full response:', result);
                        const errorMsg = (result.data && result.data.error) || result.error || 'Unknown error';
                        showNotification('Homing failed: ' + errorMsg, 'error');
                        if (homeButton) {
                            homeButton.disabled = false;
                            homeButton.textContent = '🏠 Home All';
                        }
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Home API error:', response.status, errorText);
                    showNotification(`Home request failed: ${response.status}`, 'error');
                    if (homeButton) {
                        homeButton.disabled = false;
                        homeButton.textContent = '🏠 Home All';
                    }
                }
            } catch (error) {
                console.error('Homing error:', error);
                showNotification('Homing error: ' + error.message, 'error');
                const homeButton = document.getElementById('homeAllBtn');
                if (homeButton) {
                    homeButton.disabled = false;
                    homeButton.textContent = '🏠 Home All';
                }
            }
        }
        
        async function capturePhoto() {
            try {
                console.log('Capturing photo...');
                showNotification('Capturing photo...', 'info');
                
                const response = await fetch('/api/camera/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ camera_id: 0 })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Photo captured successfully');
                        showNotification('Photo captured successfully!', 'success');
                    } else {
                        console.error('Photo capture failed:', result.error);
                        showNotification('Photo capture failed: ' + (result.error || 'Unknown error'), 'error');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Capture API error:', response.status, errorText);
                    showNotification(`Capture request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Photo capture error:', error);
                showNotification('Photo capture error: ' + error.message, 'error');
            }
        }
        
        async function testLighting() {
            try {
                console.log('Testing lighting with calibration profile (30% intensity)...');
                showNotification('Testing lighting with calibration profile (30%)...', 'info');
                
                const response = await fetch('/api/lighting/flash', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        zone: 'all',
                        brightness: 0.3,  // 30% intensity for camera calibration
                        duration: 1000
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Lighting test successful (30% calibration intensity)');
                        showNotification('Calibration lighting test successful! (30% intensity)', 'success');
                    } else {
                        console.error('Lighting test failed:', result.error);
                        showNotification('Lighting test failed: ' + (result.error || 'Unknown error'), 'error');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Lighting API error:', response.status, errorText);
                    showNotification(`Lighting request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Lighting test error:', error);
                showNotification('Lighting test error: ' + error.message, 'error');
            }
        }
        
        async function refreshStatus() {
            try {
                console.log('Refreshing status...');
                const response = await fetch('/api/status');
                const result = await response.json();
                
                // API returns {success: true, data: {motion, cameras, lighting, scan}}
                const status = result.data || result;  // Handle both wrapped and unwrapped formats
                
                console.log('Status received:', status);
                
                // Trigger status update through Dashboard.js if available
                if (window.Dashboard && Dashboard.handleStatusUpdate) {
                    console.log('Using Dashboard.handleStatusUpdate');
                    Dashboard.handleStatusUpdate(status);
                } else {
                    console.log('Dashboard not available, using fallback');
                    // Fallback to basic updates
                    updateBasicMotionStatus({data: status});  // Wrap for compatibility
                }
                
                // Update camera status
                if (status.cameras) {
                    const countElement = document.getElementById('cameraCount');
                    if (countElement) {
                        countElement.textContent = status.cameras.available;
                    }
                    
                    const activeElement = document.getElementById('activeCameras');
                    if (activeElement) {
                        activeElement.textContent = status.cameras.active.join(', ') || 'None';
                    }
                    
                    const stateElement = document.getElementById('cameraState');
                    if (stateElement) {
                        stateElement.textContent = status.cameras.status;
                    }
                    
                    const statusElement = document.getElementById('cameraStatus');
                    if (statusElement) {
                        statusElement.className = 
                            'status-indicator ' + (status.cameras.available > 0 ? 'ready' : 'error');
                    }
                }
                
                // Update lighting status
                if (status.lighting) {
                    console.log('Lighting status:', status.lighting);
                    
                    const zonesElement = document.getElementById('lightingZones');
                    if (zonesElement) {
                        const zoneCount = status.lighting.zones ? status.lighting.zones.length : 0;
                        zonesElement.textContent = zoneCount;
                        console.log('Lighting zones count:', zoneCount);
                    }
                    
                    const stateElement = document.getElementById('lightingState');
                    if (stateElement) {
                        const lightingStatus = status.lighting.status || 'Unknown';
                        stateElement.textContent = lightingStatus;
                        console.log('Lighting state:', lightingStatus);
                    }
                    
                    const statusElement = document.getElementById('lightingStatus');
                    if (statusElement) {
                        // Check if lighting is available/ready
                        const isAvailable = status.lighting.status && 
                                          (status.lighting.status.toLowerCase() === 'available' ||
                                           status.lighting.status.toLowerCase() === 'ready' ||
                                           status.lighting.zones && status.lighting.zones.length > 0);
                        statusElement.className = 'status-indicator ' + (isAvailable ? 'ready' : 'error');
                        console.log('Lighting indicator:', isAvailable ? 'ready (green)' : 'error (red)');
                    }
                }
                
                // Update scan status
                if (status.scan) {
                    console.log('Scan status:', status.scan);
                    
                    const progressElement = document.getElementById('scanProgress');
                    if (progressElement) {
                        const progress = status.scan.progress || 0;
                        progressElement.textContent = `${progress.toFixed(1)}%`;
                    }
                    
                    const pointsElement = document.getElementById('scanPoints');
                    if (pointsElement) {
                        const current = status.scan.current_point || 0;
                        const total = status.scan.total_points || 0;
                        pointsElement.textContent = `${current}/${total}`;
                    }
                    
                    const phaseElement = document.getElementById('scanPhase');
                    if (phaseElement) {
                        phaseElement.textContent = status.scan.phase || 'idle';
                    }
                    
                    const stateElement = document.getElementById('scanState');
                    if (stateElement) {
                        const scanState = status.scan.status || status.scan.state || 'idle';
                        stateElement.textContent = scanState;
                    }
                    
                    const statusElement = document.getElementById('scanStatus');
                    if (statusElement) {
                        const scanActive = status.scan.active || false;
                        const scanState = (status.scan.status || status.scan.state || 'idle').toLowerCase();
                        const hasError = scanState === 'error';
                        
                        let statusClass = 'idle';
                        if (scanActive || scanState === 'running' || scanState === 'active') {
                            statusClass = 'busy';
                        } else if (hasError) {
                            statusClass = 'error';
                        }
                        
                        statusElement.className = 'status-indicator ' + statusClass;
                        console.log('Scan indicator:', statusClass);
                    }
                }
                
                console.log('Status refreshed successfully');
            } catch (error) {
                console.error('Status refresh error:', error);
            }
        }
        
        function updateBasicMotionStatus(status) {
            // Enhanced fallback motion status updates for all 6 fields
            // Handle both API response format {data: {motion: ...}} and direct format {motion: ...}
            const motionData = status.data?.motion || status.motion;
            
            if (motionData) {
                console.log('Updating motion status with fallback:', motionData);
                
                // Update connection status
                const connectionElement = document.getElementById('motionConnection');
                if (connectionElement) {
                    const connected = motionData.connected || false;
                    connectionElement.textContent = connected ? 'Connected' : 'Disconnected';
                    connectionElement.className = `status-value ${connected ? 'connected' : 'disconnected'}`;
                    console.log('Fallback updated motionConnection:', connected);
                }
                
                // Update homed status
                const homedElement = document.getElementById('motionHomed');
                if (homedElement) {
                    const homed = motionData.homed || motionData.is_homed || false;
                    homedElement.textContent = homed ? 'Yes' : 'No';
                    homedElement.className = `status-value ${homed ? 'homed' : 'not-homed'}`;
                    console.log('Fallback updated motionHomed:', homed);
                }
                
                // Update position using individual axis elements (consistent with manual page)
                if (motionData.position) {
                    const pos = motionData.position;
                    const axes = [
                        { id: 'currentX', value: pos.x || 0, unit: 'mm' },
                        { id: 'currentY', value: pos.y || 0, unit: 'mm' },
                        { id: 'currentZ', value: pos.z || 0, unit: '°' },
                        { id: 'currentC', value: pos.c || 0, unit: '°' }
                    ];
                    
                    axes.forEach(axis => {
                        const element = document.getElementById(axis.id);
                        if (element) {
                            element.textContent = parseFloat(axis.value).toFixed(1);
                        }
                    });
                    
                    console.log('Updated position displays:', pos);
                }
                
                // Update state
                const stateElement = document.getElementById('motionState');
                if (stateElement) {
                    const state = motionData.status || motionData.state || 'unknown';
                    stateElement.textContent = formatMotionState(state);
                    console.log('Fallback updated motionState:', state);
                }
                
                // Update activity
                const activityElement = document.getElementById('motionActivity');
                if (activityElement) {
                    const activity = motionData.activity || 'idle';
                    activityElement.textContent = formatMotionActivity(activity);
                    activityElement.className = `status-value ${getActivityClass(activity)}`;
                    console.log('Fallback updated motionActivity:', activity);
                }
                
                // Update FluidNC status
                const fluidncElement = document.getElementById('fluidncStatus');
                if (fluidncElement) {
                    const fluidncStatus = motionData.fluidnc_status || 'Unknown';
                    fluidncElement.textContent = fluidncStatus;
                    console.log('Fallback updated fluidncStatus:', fluidncStatus);
                    
                    // Color code FluidNC status
                    let statusClass = 'idle';
                    switch(fluidncStatus.toLowerCase()) {
                        case 'idle': statusClass = 'idle'; break;
                        case 'run':
                        case 'jogging': statusClass = 'busy'; break;
                        case 'homing': statusClass = 'busy'; break;
                        case 'alarm':
                        case 'error': statusClass = 'error'; break;
                        default: statusClass = 'idle';
                    }
                    fluidncElement.className = `status-value ${statusClass}`;
                }
                
                // Update main status indicator
                const statusElement = document.getElementById('motionStatus');
                if (statusElement) {
                    const isConnected = status.motion.connected || false;
                    statusElement.className = `status-indicator ${isConnected ? 'ready' : 'error'}`;
                }
            }
        }
        
        // Helper functions for fallback status formatting
        function formatMotionState(state) {
            const stateMap = {
                'idle': 'Idle',
                'busy': 'Busy',
                'homing': 'Homing',
                'error': 'Error',
                'alarm': 'Alarm',
                'unknown': 'Unknown'
            };
            return stateMap[state] || state;
        }
        
        function formatMotionActivity(activity) {
            const activityMap = {
                'idle': 'Idle',
                'homing': 'Homing',
                'moving': 'Moving',
                'positioning': 'Positioning',
                'unknown': 'Unknown'
            };
            return activityMap[activity] || activity;
        }
        
        function getActivityClass(activity) {
            switch(activity) {
                case 'idle': return 'idle';
                case 'homing':
                case 'moving':
                case 'positioning': return 'busy';
                case 'error': return 'error';
                default: return 'idle';
            }
        }
        
        function captureFromCamera(cameraId) {
            capturePhoto();
        }
        
        // Initialize Dashboard when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Dashboard page loaded, initializing...');
            
            // Check if all motion status elements exist
            const motionElements = [
                'motionConnection', 'motionHomed', 'currentX', 'currentY', 'currentZ', 'currentC', 
                'motionState', 'motionActivity', 'fluidncStatus'
            ];
            
            console.log('Checking motion status elements:');
            motionElements.forEach(id => {
                const element = document.getElementById(id);
                console.log(`${id}: ${element ? 'Found' : 'MISSING'}`);
            });
            
            // Initialize ScannerBase first
            if (window.ScannerBase) {
                console.log('Initializing ScannerBase...');
                ScannerBase.init();
            } else {
                console.warn('ScannerBase not available');
            }
            
            // Initialize Dashboard
            if (window.Dashboard) {
                console.log('Initializing Dashboard...');
                Dashboard.init();
                console.log('Dashboard initialized successfully');
            } else {
                console.warn('Dashboard.js not loaded, using fallback functions');
            }
            
            // Start camera refresh
            startCameraRefresh();
            
            // Equalize panel heights in the dashboard grid
            function equalizePanelHeights() {
                const panels = document.querySelectorAll('.status-panel, .actions-panel, .reserved-panel, .camera-panel');
                if (panels.length === 0) return;
                
                // Reset heights to auto to get natural heights
                panels.forEach(panel => {
                    panel.style.height = 'auto';
                });
                
                // Get the maximum height
                let maxHeight = 0;
                panels.forEach(panel => {
                    const height = panel.offsetHeight;
                    if (height > maxHeight) {
                        maxHeight = height;
                    }
                });
                
                // Set all panels to the maximum height
                panels.forEach(panel => {
                    panel.style.height = maxHeight + 'px';
                });
                
                console.log('📏 Equalized panel heights to:', maxHeight + 'px');
            }
            
            // Equalize heights after content loads
            setTimeout(() => {
                equalizePanelHeights();
            }, 500);
            
            // Re-equalize when window is resized
            window.addEventListener('resize', () => {
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(equalizePanelHeights, 250);
            });
            
            // Re-equalize after camera loads
            const cameraImg = document.getElementById('camera0Feed');
            if (cameraImg) {
                cameraImg.addEventListener('load', () => {
                    setTimeout(equalizePanelHeights, 100);
                });
            }
            
            // Initial status refresh after a short delay to ensure everything is loaded
            setTimeout(() => {
                console.log('Triggering initial status refresh...');
                refreshStatus();
            }, 1000);
            
            // Enable autofocus by default after page loads
            setTimeout(() => {
                triggerAutofocus();
            }, 2000); // Wait 2 seconds for camera to initialize
            
            // Initialize 3D visualization
            initializeVisualization();
        });
        
        // ==================== 3D VISUALIZATION ====================
        
        let visualizationUpdateInterval = null;
        let lastVisualizationData = null;
        
        function initializeVisualization() {
            console.log('📊 Initializing dashboard 3D visualization...');
            
            // Check if Plotly is loaded
            if (typeof Plotly === 'undefined') {
                console.error('⚠️ Plotly.js not loaded - visualization disabled');
                document.getElementById('dashboard-3d-plot').innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #d63031;">
                        <div style="text-align: center;">
                            <h4>⚠️ Plotly.js Not Loaded</h4>
                            <p style="font-size: 0.85rem;">3D visualization requires Plotly.js library</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Initial fetch and render
            updateVisualization();
            
            // Set up periodic updates (every 1 second)
            visualizationUpdateInterval = setInterval(updateVisualization, 1000);
            
            console.log('✅ Dashboard visualization initialized');
        }
        
        async function updateVisualization() {
            try {
                const response = await fetch('/api/visualization_data');
                const data = await response.json();
                
                if (!data.success) {
                    console.error('Visualization data error:', data.error);
                    return;
                }
                
                // Update mode indicator
                const modeIndicator = document.getElementById('viz-mode-indicator');
                if (data.mode === 'scanning') {
                    modeIndicator.textContent = `🔄 Scanning (${data.progress.current_point}/${data.progress.total_points})`;
                    modeIndicator.style.color = '#2ecc71';
                } else {
                    modeIndicator.textContent = '📍 Idle - Live Position';
                    modeIndicator.style.color = '#64748b';
                }
                
                // Update info panel
                updateVisualizationInfo(data);
                
                // Render 3D plot
                renderVisualization(data);
                
                lastVisualizationData = data;
                
            } catch (error) {
                console.error('Failed to update visualization:', error);
            }
        }
        
        function updateVisualizationInfo(data) {
            const currentPosEl = document.getElementById('viz-current-pos');
            const scanProgressEl = document.getElementById('viz-scan-progress');
            
            if (data.current_position && data.current_position.camera) {
                const cam = data.current_position.camera;
                currentPosEl.textContent = `R:${cam.radius.toFixed(1)}mm H:${cam.height.toFixed(1)}mm θ:${cam.rotation.toFixed(1)}° T:${cam.tilt.toFixed(1)}°`;
            } else {
                currentPosEl.textContent = 'Unknown';
            }
            
            if (data.mode === 'scanning') {
                scanProgressEl.textContent = `${data.progress.current_point}/${data.progress.total_points} (${data.progress.percentage.toFixed(1)}%)`;
            } else {
                scanProgressEl.textContent = 'No active scan';
            }
        }
        
        function renderVisualization(data) {
            const plotDiv = document.getElementById('dashboard-3d-plot');
            
            if (!plotDiv) {
                console.error('Plot div not found');
                return;
            }
            
            const traces = [];
            
            // Add turntable (10cm diameter = 100mm)
            const turntableRadius = 50; // 50mm radius
            const turntablePoints = 50;
            const turntableTheta = Array.from({length: turntablePoints + 1}, (_, i) => i * 2 * Math.PI / turntablePoints);
            const turntableX = turntableTheta.map(t => turntableRadius * Math.cos(t));
            const turntableY = turntableTheta.map(t => turntableRadius * Math.sin(t));
            const turntableZ = Array(turntablePoints + 1).fill(0);
            
            traces.push({
                type: 'scatter3d',
                mode: 'lines',
                name: 'Turntable',
                x: turntableX,
                y: turntableY,
                z: turntableZ,
                line: {
                    color: 'rgba(80, 80, 80, 0.8)',
                    width: 4
                },
                hoverinfo: 'name',
                showlegend: false
            });
            
            // SCANNING MODE: Show all scan points
            if (data.mode === 'scanning' && data.scan_points.length > 0) {
                const scanPoints = data.scan_points;
                
                // Convert to Cartesian coordinates
                const cartesianPoints = scanPoints.map(p => {
                    const z_rad = p.camera.rotation * Math.PI / 180;
                    return {
                        x: p.camera.radius * Math.cos(z_rad),
                        y: p.camera.radius * Math.sin(z_rad),
                        z: p.camera.height
                    };
                });
                
                const xCoords = cartesianPoints.map(p => p.x);
                const yCoords = cartesianPoints.map(p => p.y);
                const zCoords = cartesianPoints.map(p => p.z);
                
                // Create color array (gradient through scan path)
                const colors = scanPoints.map((_, i) => i);
                
                // Hover text
                const hoverText = scanPoints.map((p, i) => 
                    `Point ${i}<br>Radius: ${p.camera.radius.toFixed(1)}mm<br>Height: ${p.camera.height.toFixed(1)}mm<br>Rotation: ${p.camera.rotation.toFixed(1)}°<br>Tilt: ${p.camera.tilt.toFixed(1)}°`
                );
                
                // Scan path trace
                traces.push({
                    type: 'scatter3d',
                    mode: 'lines+markers',
                    name: 'Scan Path',
                    x: xCoords,
                    y: yCoords,
                    z: zCoords,
                    text: hoverText,
                    hoverinfo: 'text',
                    marker: {
                        size: 4,
                        color: colors,
                        colorscale: 'Portland',
                        showscale: false
                    },
                    line: {
                        color: colors,
                        colorscale: 'Portland',
                        width: 2
                    },
                    showlegend: false
                });
                
                // Highlight current position in scan
                if (data.current_position && data.current_position.camera) {
                    const cam = data.current_position.camera;
                    const z_rad = cam.rotation * Math.PI / 180;
                    
                    traces.push({
                        type: 'scatter3d',
                        mode: 'markers',
                        name: 'Current Position',
                        x: [cam.radius * Math.cos(z_rad)],
                        y: [cam.radius * Math.sin(z_rad)],
                        z: [cam.height],
                        marker: {
                            size: 10,
                            color: '#e74c3c',
                            symbol: 'diamond',
                            line: {
                                color: 'white',
                                width: 2
                            }
                        },
                        hovertext: `CURRENT<br>R:${cam.radius.toFixed(1)}mm<br>H:${cam.height.toFixed(1)}mm<br>θ:${cam.rotation.toFixed(1)}°<br>T:${cam.tilt.toFixed(1)}°`,
                        hoverinfo: 'text',
                        showlegend: false
                    });
                }
            }
            // IDLE MODE: Show only current position
            else if (data.current_position && data.current_position.camera) {
                const cam = data.current_position.camera;
                const z_rad = cam.rotation * Math.PI / 180;
                
                traces.push({
                    type: 'scatter3d',
                    mode: 'markers',
                    name: 'Camera Position',
                    x: [cam.radius * Math.cos(z_rad)],
                    y: [cam.radius * Math.sin(z_rad)],
                    z: [cam.height],
                    marker: {
                        size: 12,
                        color: '#3498db',
                        symbol: 'diamond',
                        line: {
                            color: 'white',
                            width: 2
                        }
                    },
                    hovertext: `Camera<br>R:${cam.radius.toFixed(1)}mm<br>H:${cam.height.toFixed(1)}mm<br>θ:${cam.rotation.toFixed(1)}°<br>T:${cam.tilt.toFixed(1)}°`,
                    hoverinfo: 'text',
                    showlegend: false
                });
            }
            
            // Layout with auto-scaling (matches scan path preview settings)
            const layout = {
                scene: {
                    xaxis: { title: 'X (mm)', showgrid: true, zeroline: true },
                    yaxis: { title: 'Y (mm)', showgrid: true, zeroline: true },
                    zaxis: { title: 'Height (mm)', showgrid: true, zeroline: true },
                    camera: {
                        eye: { x: 1.5, y: -1.5, z: 1.0 },
                        up: { x: 0, y: 0, z: 1 }
                    },
                    aspectmode: 'data',
                    aspectratio: { x: 1, y: 1, z: 0.8 }
                },
                margin: { l: 0, r: 0, b: 0, t: 0 },
                showlegend: false
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['toImage']
            };
            
            // Use Plotly.react() to update without resetting camera position
            Plotly.react(plotDiv, traces, layout, config).then(() => {
                // Force Plotly to resize to fill container after initial render
                setTimeout(() => {
                    Plotly.Plots.resize(plotDiv);
                }, 100);
            });
        }
        
        // Handle window resize to ensure plot fills container
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const plotDiv = document.getElementById('dashboard-3d-plot');
                if (plotDiv && typeof Plotly !== 'undefined') {
                    Plotly.Plots.resize(plotDiv);
                }
            }, 250);
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (visualizationUpdateInterval) {
                clearInterval(visualizationUpdateInterval);
            }
        });
    </script>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing...</div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/dashboard.js') }}"></script>
{% endblock %}