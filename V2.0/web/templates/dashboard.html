{% extends "base.html" %}

{% block title %}Dashboard - 3D Scanner Control{% endblock %}

{% block head %}
<style>
    .camera-controls-panel {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border: 1px solid #dee2e6;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .control-group {
        background: white;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid #e9ecef;
    }
    
    .control-group label {
        color: #495057;
        font-weight: 600;
        font-size: 0.8rem;
    }
    
    .btn {
        padding: 3px 6px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7rem;
        transition: all 0.2s;
    }
    
    .btn-primary {
        background: #007bff;
        color: white;
    }
    
    .btn-primary:hover {
        background: #0056b3;
    }
    
    .btn-secondary {
        background: #6c757d;
        color: white;
    }
    
    .btn-secondary:hover {
        background: #545b62;
    }
    
    .btn-sm {
        padding: 2px 4px;
        font-size: 0.65rem;
    }
    
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: #ddd;
        border-radius: 3px;
        outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
    }
    
    .status-info { color: #17a2b8; }
    .status-success { color: #28a745; }
    .status-error { color: #dc3545; }
    
    .action-btn.emergency {
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: white;
        border: 2px solid #b21f2d;
        font-weight: bold;
        animation: pulse-emergency 2s infinite;
    }
    
    .action-btn.emergency:hover {
        background: linear-gradient(135deg, #c82333, #a71e2a);
        transform: scale(1.05);
    }
    
    @keyframes pulse-emergency {
        0%, 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4); }
        50% { box-shadow: 0 0 0 8px rgba(220, 53, 69, 0); }
    }
    
    /* Responsive Dashboard Grid */
    .dashboard-grid {
        display: grid;
        grid-template-columns: minmax(180px, 200px) minmax(180px, 200px) minmax(300px, 1fr) minmax(300px, 1fr);
        gap: 0.75rem;
        grid-template-rows: auto auto;
        margin-bottom: 0.75rem;
        width: 100%;
    }
    
    /* Ensure main content allows horizontal scrolling on smaller screens */
    .main-content {
        flex: 1;
        padding: 0.5rem;
        width: 100%;
        max-width: none;
        margin: 0;
        overflow-x: auto;
        overflow-y: auto;
    }
    
    /* Responsive breakpoints */
    @media screen and (max-width: 1400px) {
        .dashboard-grid {
            grid-template-columns: 180px 180px 1fr 1fr;
            min-width: 1200px; /* Force horizontal scroll on smaller screens */
        }
    }
    
    @media screen and (max-width: 1200px) {
        .dashboard-grid {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            min-width: auto;
        }
        
        .status-panel {
            grid-column: 1 / 2 !important;
            grid-row: 1 / 2 !important;
        }
        
        .actions-panel {
            grid-column: 2 / 3 !important;
            grid-row: 1 / 2 !important;
        }
        
        .reserved-panel {
            grid-column: 1 / 2 !important;
            grid-row: 2 / 3 !important;
        }
        
        .camera-panel {
            grid-column: 2 / 3 !important;
            grid-row: 2 / 3 !important;
        }
        
        .log-panel {
            grid-column: 1 / 3 !important;
            grid-row: 3 / 4 !important;
        }
    }
</style>
{% endblock %}

{% block content %}
<main class="main-content">
<div class="dashboard-grid">
    <!-- Column 1: System Status Panel (Thin) -->
    <section class="status-panel" style="grid-row: 1 / 2; grid-column: 1 / 2;">
        <h2 style="font-size: 1rem; margin-bottom: 0.5rem;">System Status</h2>
        <div class="status-grid" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Motion Controller</span>
                    <span class="status-indicator" id="motionStatus" style="font-size: 0.9rem;">‚óè</span>
                </div>
                <div class="status-details" id="motionDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Connection: <span id="motionConnection" class="status-value">Unknown</span></div>
                    <div>Homed: <span id="motionHomed" class="status-value">Unknown</span></div>
                    <div style="font-size: 0.65rem;">Position: 
                        <div style="margin-left: 0.3rem;">
                            X:<span id="currentX">0.0</span>mm
                            Y:<span id="currentY">0.0</span>mm
                        </div>
                        <div style="margin-left: 0.3rem;">
                            Z:<span id="currentZ">0.0</span>¬∞
                            C:<span id="currentC">0.0</span>¬∞
                        </div>
                    </div>
                    <div>State: <span id="motionState">Unknown</span></div>
                    <div>Activity: <span id="motionActivity" class="status-value">Unknown</span></div>
                    <div>FluidNC: <span id="fluidncStatus" class="status-value">Unknown</span></div>
                </div>
            </div>

            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Cameras</span>
                    <span class="status-indicator" id="cameraStatus" style="font-size: 0.9rem;">‚óè</span>
                </div>
                <div class="status-details" id="cameraDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Available: <span id="cameraCount">0</span></div>
                    <div>Active: <span id="activeCameras">None</span></div>
                    <div>State: <span id="cameraState">Unknown</span></div>
                </div>
            </div>

            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Lighting</span>
                    <span class="status-indicator" id="lightingStatus" style="font-size: 0.9rem;">‚óè</span>
                </div>
                <div class="status-details" id="lightingDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Zones: <span id="lightingZones">0</span></div>
                    <div>Status: <span id="lightingState">Unknown</span></div>
                </div>
            </div>

            <div class="status-item" style="background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
                <div class="status-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                    <span class="status-label" style="font-weight: 600; font-size: 0.8rem;">Current Scan</span>
                    <span class="status-indicator" id="scanStatus" style="font-size: 0.9rem;">‚óè</span>
                </div>
                <div class="status-details" id="scanDetails" style="font-size: 0.7rem; color: #6c757d;">
                    <div>Progress: <span id="scanProgress">---%</span></div>
                    <div>Points: <span id="scanPoints">0/0</span></div>
                    <div>Phase: <span id="scanPhase">Idle</span></div>
                    <div>State: <span id="scanState">Unknown</span></div>
                </div>
            </div>
        </div>
    </section>

    <!-- Column 2: Quick Actions Panel (Thin) -->
    <section class="actions-panel" style="grid-row: 1 / 2; grid-column: 2 / 3;">
        <h2 style="font-size: 1rem; margin-bottom: 0.5rem;">Quick Actions</h2>
        <div class="action-grid" style="display: flex; flex-direction: column; gap: 0.4rem;">
            <button class="action-btn primary" onclick="homeAllAxes()" id="homeAllBtn" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: linear-gradient(135deg, #007bff, #0056b3); color: white; font-weight: 600; transition: all 0.2s;">
                üè† Home All
            </button>
            <button class="action-btn secondary" onclick="capturePhoto()" id="captureBtn" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #6c757d; color: white; transition: all 0.2s;">
                üì∏ Capture Photo
            </button>
            <button class="action-btn secondary" onclick="testLighting()" id="lightTestBtn" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #6c757d; color: white; transition: all 0.2s;">
                ‚ö° Test Lighting
            </button>
            <button class="action-btn secondary" onclick="testNotifications()" id="testNotifyBtn" title="Test notification stacking" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #6c757d; color: white; transition: all 0.2s;">
                üîî Test Alerts
            </button>
            <button class="action-btn emergency" onclick="cancelAllScans()" id="cancelAllBtn" title="Emergency: Stop all scanning operations" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: 2px solid #b21f2d; cursor: pointer; font-weight: bold;">
                üõë Cancel All Scans
            </button>
            <button class="action-btn tertiary" onclick="window.location.href='/manual'" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #17a2b8; color: white; transition: all 0.2s;">
                üéÆ Manual Control
            </button>
            <button class="action-btn tertiary" onclick="window.location.href='/scans'" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #17a2b8; color: white; transition: all 0.2s;">
                üìä Start Scan
            </button>
            <button class="action-btn tertiary" onclick="refreshStatus()" style="padding: 0.5rem; font-size: 0.75rem; border-radius: 6px; border: none; cursor: pointer; background: #17a2b8; color: white; transition: all 0.2s;">
                üîÑ Refresh Status
            </button>
        </div>
    </section>

    <!-- Column 3: Reserved Space (Wider) -->
    <section class="reserved-panel" style="grid-row: 1 / 2; grid-column: 3 / 4; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%); border: 3px dashed #cbd5e1; display: flex; align-items: center; justify-content: center; min-height: 500px; position: relative; overflow: hidden; border-radius: 8px;">
        <!-- Background pattern -->
        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.1; background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, #64748b 10px, #64748b 20px);"></div>
        
        <!-- Content -->
        <div style="text-align: center; color: #64748b; z-index: 1; max-width: 80%;">
            <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.7;">üìäüìàüìâ</div>
            <div style="font-weight: 700; margin-bottom: 0.5rem; font-size: 1.4rem; color: #475569;">Reserved Visualization Space</div>
            <div style="font-size: 1rem; margin-bottom: 1rem; line-height: 1.4;">
                This area is reserved for future data visualization, charts, 3D previews, or monitoring dashboards
            </div>
            <div style="font-size: 0.85rem; background: rgba(255, 255, 255, 0.8); padding: 0.5rem 1rem; border-radius: 0.5rem; display: inline-block; color: #64748b;">
                <strong>Dimensions:</strong> Flexible ‚Ä¢ <strong>Purpose:</strong> Analytics & Visualization
            </div>
        </div>
    </section>

    <!-- Column 4: Live Camera Feed (Wider) -->
    <section class="camera-panel" style="grid-row: 1 / 2; grid-column: 4 / 5;">
        <h2 style="font-size: 1rem; margin-bottom: 0.5rem;">Live Camera Feed</h2>
        <div class="camera-grid">
            <div class="camera-container">
                <h3 style="font-size: 0.85rem; margin-bottom: 0.4rem;">Camera 0 - Native 1080p Stream</h3>
                <div class="camera-feed-wrapper" style="position: relative;">
                    <img id="camera0Feed" 
                         src="/camera/0?t=0" 
                         alt="Camera 0 - 1080p Stream" 
                         class="camera-feed"
                         style="width: 100%; height: auto; border-radius: 8px;"
                         onload="cameraStreamWorking = true; console.log('Camera 0 native 1080p stream loaded');"
                         onerror="console.log('Camera 0 stream error, retrying...'); setTimeout(() => { const timestamp = Date.now(); this.src = '/camera/0?t=' + timestamp; }, 2000);">
                    <div class="camera-overlay" style="position: absolute; bottom: 10px; right: 10px; display: flex; gap: 0.5rem;">
                        <button class="camera-control modern-btn capture-btn" onclick="captureFromCamera(0)" title="Capture High-Resolution Photo" style="padding: 0.4rem 0.6rem; font-size: 0.7rem; border-radius: 6px; border: none; background: #007bff; color: white; cursor: pointer;">
                            <span class="btn-icon">üì∏</span>
                            <span class="btn-text">Capture</span>
                        </button>
                        <button class="camera-control modern-btn refresh-btn" onclick="manualRefreshCamera()" title="Refresh Camera Stream" style="padding: 0.4rem 0.6rem; font-size: 0.7rem; border-radius: 6px; border: none; background: #6c757d; color: white; cursor: pointer;">
                            <span class="btn-icon">üîÑ</span>
                            <span class="btn-text">Refresh</span>
                        </button>
                    </div>
                </div>
                <div class="camera-info" style="margin-top: 0.3rem;">
                    <small style="font-size: 0.7rem; color: #6c757d;">üé• Live 1080p stream ‚Ä¢ üì∏ High-res capture available during scanning</small>
                </div>
                
                <!-- Camera Controls - Compact -->
                <div class="camera-controls-panel" style="margin-top: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                    <h4 style="font-size: 0.85rem; margin-bottom: 0.4rem;">Camera Controls</h4>
                    <div class="controls-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem;">
                        <!-- Focus Controls -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">Focus Control</label>
                            <div style="display: flex; gap: 0.2rem; margin-bottom: 0.4rem;">
                                <button class="btn btn-sm btn-primary" onclick="triggerAutofocus()" style="padding: 0.2rem 0.3rem; font-size: 0.65rem;">üéØ Auto</button>
                                <button class="btn btn-sm btn-secondary" onclick="toggleManualFocus()" style="padding: 0.2rem 0.3rem; font-size: 0.65rem;">‚öôÔ∏è Manual</button>
                                <button id="stabilizeBtn" class="btn btn-sm btn-warning" onclick="toggleStabilization()" style="padding: 0.2rem 0.3rem; font-size: 0.65rem;">üîß Stab</button>
                            </div>
                            <div id="manualFocusPanel" style="display: none;">
                                <label for="focusSlider" style="font-size: 0.65rem;">Focus Position (0=Near, 10=Far)</label>
                                <input type="range" id="focusSlider" min="0" max="10" step="0.1" value="5" 
                                       style="width: 100%;" onchange="setManualFocus(this.value)">
                                <span id="focusValue" style="font-size: 0.65rem;">5.0</span>
                            </div>
                        </div>
                        
                        <!-- Exposure Controls -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">Exposure Control</label>
                            <div style="margin-bottom: 0.4rem;">
                                <label style="display: flex; align-items: center; font-size: 0.7rem;">
                                    <input type="checkbox" id="autoExposure" checked onchange="toggleAutoExposure(this.checked)">
                                    <span style="margin-left: 0.3rem;">Auto Exposure</span>
                                </label>
                            </div>
                            <div id="manualExposurePanel" style="display: none;">
                                <label for="exposureSlider" style="font-size: 0.65rem;">Exposure Time (ms)</label>
                                <input type="range" id="exposureSlider" min="1" max="100" value="10" 
                                       style="width: 100%;" onchange="setExposureTime(this.value)">
                                <span id="exposureValue" style="font-size: 0.65rem;">10ms</span>
                            </div>
                        </div>
                        
                        <!-- ISO Controls -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label for="isoSlider" style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">ISO Setting</label>
                            <input type="range" id="isoSlider" min="100" max="1600" step="100" value="400" 
                                   style="width: 100%;" onchange="setISO(this.value)">
                            <span id="isoValue" style="font-size: 0.65rem;">ISO 400</span>
                        </div>
                        
                        <!-- White Balance -->
                        <div class="control-group" style="padding: 0.4rem; background: white; border-radius: 4px; border: 1px solid #e9ecef;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.75rem;">White Balance</label>
                            <div style="margin-bottom: 0.3rem;">
                                <label style="display: flex; align-items: center; font-size: 0.7rem;">
                                    <input type="checkbox" id="autoWhiteBalance" checked onchange="toggleAutoWhiteBalance(this.checked)">
                                    <span style="margin-left: 0.3rem;">Auto White Balance</span>
                                </label>
                            </div>
                            <div id="manualWhiteBalancePanel" style="display: none;">
                                <label style="font-size: 0.65rem; display: block; margin-bottom: 0.2rem;">White Balance Mode</label>
                                <select id="whiteBalanceMode" style="width: 100%; padding: 0.2rem; margin-bottom: 0.3rem; font-size: 0.65rem;" onchange="setWhiteBalanceMode(this.value)">
                                    <option value="indoor">üè† Indoor</option>
                                    <option value="daylight">‚òÄÔ∏è Daylight</option>
                                    <option value="tungsten">üí° Tungsten</option>
                                </select>
                                <button class="btn btn-sm btn-success" onclick="lockWhiteBalance()" style="width: 100%; padding: 0.2rem; font-size: 0.65rem;">
                                    üîí Lock Current WB
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Status Display -->
                    <div id="controlsStatus" style="margin-top: 0.4rem; padding: 0.3rem; background: #e9ecef; border-radius: 4px; font-size: 0.65rem; text-align: center;">
                        Status: Ready
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Activity Log Panel - Full Width Bottom (spans all 4 columns) -->
    <section class="log-panel" style="grid-column: 1 / 5; grid-row: 2 / 3;">
        <h2 style="font-size: 0.9rem; margin-bottom: 0.5rem;">Activity Log</h2>
        <div class="log-container" style="max-height: 120px; background: white; padding: 0.5rem; border-radius: 6px; border: 1px solid #e9ecef;">
            <div id="activityLog" class="log-content" style="font-size: 0.75rem; max-height: 90px; overflow-y: auto;">
                <div class="log-entry info">
                    <span class="log-timestamp">{{ status.timestamp[:19] if status.timestamp else '--:--:--' }}</span>
                    <span class="log-message">Web interface initialized</span>
                </div>
            </div>
            <div class="log-controls" style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                <button onclick="clearLog()" class="log-control-btn" style="padding: 0.2rem 0.5rem; font-size: 0.7rem; border-radius: 4px; border: 1px solid #6c757d; background: white; cursor: pointer;">Clear</button>
                <button onclick="downloadLog()" class="log-control-btn" style="padding: 0.2rem 0.5rem; font-size: 0.7rem; border-radius: 4px; border: 1px solid #6c757d; background: white; cursor: pointer;">Download</button>
                <label class="log-control-checkbox" style="font-size: 0.7rem; display: flex; align-items: center; gap: 0.3rem;">
                    <input type="checkbox" id="autoScroll" checked>
                    Auto-scroll
                </label>
            </div>
        </div>
    </section>
</div>
</main>

    <script>
        // High-performance camera stream management
        let cameraStreamWorking = false;
        let refreshInterval = null;
        let streamCheckInterval = null;
        
        function startCameraRefresh() {
            // Initial load only - no automatic refresh
            refreshCameraStream();
            
            // Only monitor stream health for error recovery
            streamCheckInterval = setInterval(checkStreamHealth, 5000);  // Every 5 seconds
        }
        
        function refreshCameraStream() {
            const camera0Feed = document.getElementById('camera0Feed');
            if (camera0Feed) {
                const timestamp = Date.now();
                console.log('Refreshing Camera 0 stream...');
                camera0Feed.src = '/camera/0?t=' + timestamp;
            }
        }
        
        function checkStreamHealth() {
            const camera0Feed = document.getElementById('camera0Feed');
            if (camera0Feed && !cameraStreamWorking) {
                console.log('Camera stream health check failed - refreshing for error recovery...');
                refreshCameraStream();
            }
            // Reset flag for next check
            cameraStreamWorking = false;
        }
        
        function manualRefreshCamera() {
            console.log('Manual camera refresh requested by user');
            refreshCameraStream();
        }
        
        function stopCameraRefresh() {
            // Only need to stop health check interval (no automatic refresh anymore)
            if (streamCheckInterval) {
                clearInterval(streamCheckInterval);
                streamCheckInterval = null;
            }
        }
        
        // Stop refresh when page unloads
        window.addEventListener('beforeunload', stopCameraRefresh);
        
        // Camera Control Functions
        async function triggerAutofocus() {
            try {
                updateControlsStatus('Triggering autofocus...', 'info');
                
                const response = await fetch('/api/camera/autofocus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ camera_id: 'camera_1' })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus('Autofocus triggered successfully', 'success');
                } else {
                    updateControlsStatus('Autofocus failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Autofocus error: ' + error.message, 'error');
                console.error('Autofocus error:', error);
            }
        }
        
        function toggleManualFocus() {
            const panel = document.getElementById('manualFocusPanel');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Disable autofocus when switching to manual
                setCameraControls({ autofocus: false });
            }
        }
        
        async function setManualFocus(position) {
            try {
                document.getElementById('focusValue').textContent = parseFloat(position).toFixed(1);
                
                const response = await fetch('/api/camera/focus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        focus_position: parseFloat(position)
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus(`Manual focus set to ${position}`, 'success');
                } else {
                    updateControlsStatus('Focus setting failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Focus setting error: ' + error.message, 'error');
                console.error('Manual focus error:', error);
            }
        }
        
        let stabilizationEnabled = false;
        async function toggleStabilization() {
            try {
                stabilizationEnabled = !stabilizationEnabled;
                const btn = document.getElementById('stabilizeBtn');
                
                const response = await fetch('/api/camera/stabilize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        enable: stabilizationEnabled
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    btn.textContent = stabilizationEnabled ? 'üîí Stabilized' : 'üîß Stabilize';
                    btn.className = stabilizationEnabled ? 'btn btn-sm btn-success' : 'btn btn-sm btn-warning';
                    updateControlsStatus(stabilizationEnabled ? 'Camera stabilization enabled' : 'Camera stabilization disabled', 'info');
                } else {
                    updateControlsStatus('Stabilization toggle failed: ' + (result.error || 'Unknown error'), 'error');
                    stabilizationEnabled = !stabilizationEnabled; // Revert on failure
                }
            } catch (error) {
                updateControlsStatus('Stabilization error: ' + error.message, 'error');
                console.error('Stabilization error:', error);
                stabilizationEnabled = !stabilizationEnabled; // Revert on failure
            }
        }
        
        function toggleAutoExposure(enabled) {
            const panel = document.getElementById('manualExposurePanel');
            panel.style.display = enabled ? 'none' : 'block';
            setCameraControls({ auto_exposure: enabled });
        }
        
        function setExposureTime(timeMs) {
            document.getElementById('exposureValue').textContent = timeMs + 'ms';
            setCameraControls({ 
                auto_exposure: false,
                exposure_time: parseInt(timeMs)
            });
        }
        
        function setISO(isoValue) {
            document.getElementById('isoValue').textContent = 'ISO ' + isoValue;
            setCameraControls({ iso: parseInt(isoValue) });
        }
        
        function toggleAutoWhiteBalance(enabled) {
            const panel = document.getElementById('manualWhiteBalancePanel');
            panel.style.display = enabled ? 'none' : 'block';
            setWhiteBalanceMode(enabled ? 'auto' : 'indoor');
        }
        
        async function setWhiteBalanceMode(mode) {
            try {
                const response = await fetch('/api/camera/white_balance', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        mode: mode
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus(`White balance set to ${mode}`, 'success');
                } else {
                    updateControlsStatus('White balance setting failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('White balance error: ' + error.message, 'error');
                console.error('White balance error:', error);
            }
        }
        
        async function lockWhiteBalance() {
            const mode = document.getElementById('whiteBalanceMode').value;
            await setWhiteBalanceMode(mode);
            updateControlsStatus(`White balance locked to ${mode} mode`, 'info');
        }
        
        function toggleAutoWhiteBalance(enabled) {
            setCameraControls({ auto_white_balance: enabled });
        }
        
        async function setCameraControls(controls) {
            try {
                updateControlsStatus('Applying camera settings...', 'info');
                
                const response = await fetch('/api/camera/controls', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        controls: controls
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus('Settings applied successfully', 'success');
                } else {
                    updateControlsStatus('Settings failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Settings error: ' + error.message, 'error');
                console.error('Camera controls error:', error);
            }
        }
        
        function updateControlsStatus(message, type) {
            const statusElement = document.getElementById('controlsStatus');
            if (statusElement) {
                statusElement.textContent = 'Status: ' + message;
                statusElement.className = 'status-' + type;
                
                // Clear status after 3 seconds for non-error messages
                if (type !== 'error') {
                    setTimeout(() => {
                        statusElement.textContent = 'Status: Ready';
                        statusElement.className = '';
                    }, 3000);
                }
            }
        }
        
        // Motion Control Functions
        // Notification system - now uses the improved ScannerBase alert system
        function showNotification(message, type = 'info') {
            // Use the new ScannerBase alert system which properly handles positioning and stacking
            ScannerBase.showAlert(message, type, 5000, false);
        }

        // Test notification system to demonstrate proper stacking and positioning
        function testNotifications() {
            const messages = [
                { msg: 'Test success notification', type: 'success' },
                { msg: 'Test warning notification', type: 'warning' },
                { msg: 'Test error notification', type: 'error' },
                { msg: 'Test info notification', type: 'info' }
            ];
            
            messages.forEach((notification, index) => {
                setTimeout(() => {
                    showNotification(notification.msg, notification.type);
                }, index * 500); // Stagger by 500ms each
            });
        }

        // Emergency function to cancel all scanning operations
        async function cancelAllScans() {
            try {
                console.log('Emergency: Canceling all scans...');
                
                // Disable button temporarily
                const cancelButton = document.getElementById('cancelAllBtn');
                if (cancelButton) {
                    cancelButton.disabled = true;
                    cancelButton.textContent = 'üîÑ Canceling...';
                }
                
                showNotification('Emergency: Stopping all scans...', 'warning');
                
                // Call the scan stop API
                const response = await fetch('/api/scan/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('All scans stopped successfully');
                        showNotification('All scanning operations stopped', 'success');
                    } else {
                        console.warn('Stop command sent but result unclear:', result);
                        showNotification('Stop command sent - check scan status', 'warning');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Cancel API error:', response.status, errorText);
                    showNotification(`Cancel failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Cancel all scans error:', error);
                showNotification('Cancel error: ' + error.message, 'error');
            } finally {
                // Re-enable button
                const cancelButton = document.getElementById('cancelAllBtn');
                if (cancelButton) {
                    cancelButton.disabled = false;
                    cancelButton.textContent = 'üõë Cancel All Scans';
                }
                
                // Refresh status to show updated state
                refreshStatus();
            }
        }

        async function homeAllAxes() {
            try {
                console.log('Starting homing sequence...');
                
                // Disable button during homing
                const homeButton = document.getElementById('homeAllBtn');
                if (homeButton) {
                    homeButton.disabled = true;
                    homeButton.textContent = 'Homing...';
                }
                
                showNotification('Starting homing sequence...', 'info');
                
                const response = await fetch('/api/home', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ axes: ['X', 'Y', 'Z', 'C'] })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Homing API response:', result); // Debug logging
                    
                    if (result.success && result.data && result.data.status === 'in_progress') {
                        console.log('Homing started, will listen for completion via status updates');
                        showNotification('Homing in progress...', 'warning');
                        
                        // Use existing status update system instead of separate polling
                        let homingStartTime = Date.now();
                        let homingTimeout = null;
                        let isWaitingForHoming = true;
                        
                        // Set a maximum timeout (4 minutes)
                        homingTimeout = setTimeout(() => {
                            if (isWaitingForHoming) {
                                isWaitingForHoming = false;
                                console.log('Homing timeout - no completion detected');
                                showNotification('Homing timeout - check system status', 'error');
                                if (homeButton) {
                                    homeButton.disabled = false;
                                    homeButton.textContent = 'üè† Home All';
                                }
                            }
                        }, 240000); // 4 minutes
                        
                        // Listen for the next status update that shows homing complete
                        const homingCompleteHandler = (event) => {
                            if (!isWaitingForHoming) return;
                            
                            const status = event.detail.status;
                            if (status.motion && (status.motion.homed === true || status.motion.is_homed === true)) {
                                isWaitingForHoming = false;
                                clearTimeout(homingTimeout);
                                document.removeEventListener('scanner:statusUpdate', homingCompleteHandler);
                                
                                const elapsed = Math.round((Date.now() - homingStartTime) / 1000);
                                console.log(`‚úÖ Homing completed in ${elapsed}s via status update!`);
                                showNotification(`All axes homed successfully! (${elapsed}s)`, 'success');
                                
                                if (homeButton) {
                                    homeButton.disabled = false;
                                    homeButton.textContent = 'üè† Home All';
                                }
                            } else {
                                // Progress tracking is handled by dashboard.js, no need for duplicate messages
                            }
                        };
                        
                        // Listen for status updates instead of polling
                        document.addEventListener('scanner:statusUpdate', homingCompleteHandler);
                        
                    } else {
                        console.error('Homing failed. Full response:', result);
                        const errorMsg = (result.data && result.data.error) || result.error || 'Unknown error';
                        showNotification('Homing failed: ' + errorMsg, 'error');
                        if (homeButton) {
                            homeButton.disabled = false;
                            homeButton.textContent = 'üè† Home All';
                        }
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Home API error:', response.status, errorText);
                    showNotification(`Home request failed: ${response.status}`, 'error');
                    if (homeButton) {
                        homeButton.disabled = false;
                        homeButton.textContent = 'üè† Home All';
                    }
                }
            } catch (error) {
                console.error('Homing error:', error);
                showNotification('Homing error: ' + error.message, 'error');
                const homeButton = document.getElementById('homeAllBtn');
                if (homeButton) {
                    homeButton.disabled = false;
                    homeButton.textContent = 'üè† Home All';
                }
            }
        }
        
        async function capturePhoto() {
            try {
                console.log('Capturing photo...');
                showNotification('Capturing photo...', 'info');
                
                const response = await fetch('/api/camera/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ camera_id: 0 })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Photo captured successfully');
                        showNotification('Photo captured successfully!', 'success');
                    } else {
                        console.error('Photo capture failed:', result.error);
                        showNotification('Photo capture failed: ' + (result.error || 'Unknown error'), 'error');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Capture API error:', response.status, errorText);
                    showNotification(`Capture request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Photo capture error:', error);
                showNotification('Photo capture error: ' + error.message, 'error');
            }
        }
        
        async function testLighting() {
            try {
                console.log('Testing lighting...');
                showNotification('Testing lighting...', 'info');
                
                const response = await fetch('/api/lighting/flash', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        zone: 'all',
                        brightness: 0.5,
                        duration: 1000
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Lighting test successful');
                        showNotification('Lighting test successful!', 'success');
                    } else {
                        console.error('Lighting test failed:', result.error);
                        showNotification('Lighting test failed: ' + (result.error || 'Unknown error'), 'error');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Lighting API error:', response.status, errorText);
                    showNotification(`Lighting request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Lighting test error:', error);
                showNotification('Lighting test error: ' + error.message, 'error');
            }
        }
        
        async function refreshStatus() {
            try {
                console.log('Refreshing status...');
                const response = await fetch('/api/status');
                const status = await response.json();
                
                console.log('Status received:', status);
                
                // Trigger status update through Dashboard.js if available
                if (window.Dashboard && Dashboard.handleStatusUpdate) {
                    console.log('Using Dashboard.handleStatusUpdate');
                    Dashboard.handleStatusUpdate(status);
                } else {
                    console.log('Dashboard not available, using fallback');
                    // Fallback to basic updates
                    updateBasicMotionStatus(status);
                }
                
                // Update camera status
                if (status.cameras) {
                    const countElement = document.getElementById('cameraCount');
                    if (countElement) {
                        countElement.textContent = status.cameras.available;
                    }
                    
                    const activeElement = document.getElementById('activeCameras');
                    if (activeElement) {
                        activeElement.textContent = status.cameras.active.join(', ') || 'None';
                    }
                    
                    const stateElement = document.getElementById('cameraState');
                    if (stateElement) {
                        stateElement.textContent = status.cameras.status;
                    }
                    
                    const statusElement = document.getElementById('cameraStatus');
                    if (statusElement) {
                        statusElement.className = 
                            'status-indicator ' + (status.cameras.available > 0 ? 'ready' : 'error');
                    }
                }
                
                // Update lighting status
                if (status.lighting) {
                    const zonesElement = document.getElementById('lightingZones');
                    if (zonesElement) {
                        zonesElement.textContent = status.lighting.zones ? status.lighting.zones.length : 0;
                    }
                    
                    const stateElement = document.getElementById('lightingState');
                    if (stateElement) {
                        stateElement.textContent = status.lighting.status;
                    }
                    
                    const statusElement = document.getElementById('lightingStatus');
                    if (statusElement) {
                        statusElement.className = 
                            'status-indicator ' + (status.lighting.zones && status.lighting.zones.length > 0 ? 'ready' : 'error');
                    }
                }
                
                console.log('Status refreshed successfully');
            } catch (error) {
                console.error('Status refresh error:', error);
            }
        }
        
        function updateBasicMotionStatus(status) {
            // Enhanced fallback motion status updates for all 6 fields
            // Handle both API response format {data: {motion: ...}} and direct format {motion: ...}
            const motionData = status.data?.motion || status.motion;
            
            if (motionData) {
                console.log('Updating motion status with fallback:', motionData);
                
                // Update connection status
                const connectionElement = document.getElementById('motionConnection');
                if (connectionElement) {
                    const connected = motionData.connected || false;
                    connectionElement.textContent = connected ? 'Connected' : 'Disconnected';
                    connectionElement.className = `status-value ${connected ? 'connected' : 'disconnected'}`;
                    console.log('Fallback updated motionConnection:', connected);
                }
                
                // Update homed status
                const homedElement = document.getElementById('motionHomed');
                if (homedElement) {
                    const homed = motionData.homed || motionData.is_homed || false;
                    homedElement.textContent = homed ? 'Yes' : 'No';
                    homedElement.className = `status-value ${homed ? 'homed' : 'not-homed'}`;
                    console.log('Fallback updated motionHomed:', homed);
                }
                
                // Update position using individual axis elements (consistent with manual page)
                if (motionData.position) {
                    const pos = motionData.position;
                    const axes = [
                        { id: 'currentX', value: pos.x || 0, unit: 'mm' },
                        { id: 'currentY', value: pos.y || 0, unit: 'mm' },
                        { id: 'currentZ', value: pos.z || 0, unit: '¬∞' },
                        { id: 'currentC', value: pos.c || 0, unit: '¬∞' }
                    ];
                    
                    axes.forEach(axis => {
                        const element = document.getElementById(axis.id);
                        if (element) {
                            element.textContent = parseFloat(axis.value).toFixed(1);
                        }
                    });
                    
                    console.log('Updated position displays:', pos);
                }
                
                // Update state
                const stateElement = document.getElementById('motionState');
                if (stateElement) {
                    const state = motionData.status || motionData.state || 'unknown';
                    stateElement.textContent = formatMotionState(state);
                    console.log('Fallback updated motionState:', state);
                }
                
                // Update activity
                const activityElement = document.getElementById('motionActivity');
                if (activityElement) {
                    const activity = motionData.activity || 'idle';
                    activityElement.textContent = formatMotionActivity(activity);
                    activityElement.className = `status-value ${getActivityClass(activity)}`;
                    console.log('Fallback updated motionActivity:', activity);
                }
                
                // Update FluidNC status
                const fluidncElement = document.getElementById('fluidncStatus');
                if (fluidncElement) {
                    const fluidncStatus = motionData.fluidnc_status || 'Unknown';
                    fluidncElement.textContent = fluidncStatus;
                    console.log('Fallback updated fluidncStatus:', fluidncStatus);
                    
                    // Color code FluidNC status
                    let statusClass = 'idle';
                    switch(fluidncStatus.toLowerCase()) {
                        case 'idle': statusClass = 'idle'; break;
                        case 'run':
                        case 'jogging': statusClass = 'busy'; break;
                        case 'homing': statusClass = 'busy'; break;
                        case 'alarm':
                        case 'error': statusClass = 'error'; break;
                        default: statusClass = 'idle';
                    }
                    fluidncElement.className = `status-value ${statusClass}`;
                }
                
                // Update main status indicator
                const statusElement = document.getElementById('motionStatus');
                if (statusElement) {
                    const isConnected = status.motion.connected || false;
                    statusElement.className = `status-indicator ${isConnected ? 'ready' : 'error'}`;
                }
            }
        }
        
        // Helper functions for fallback status formatting
        function formatMotionState(state) {
            const stateMap = {
                'idle': 'Idle',
                'busy': 'Busy',
                'homing': 'Homing',
                'error': 'Error',
                'alarm': 'Alarm',
                'unknown': 'Unknown'
            };
            return stateMap[state] || state;
        }
        
        function formatMotionActivity(activity) {
            const activityMap = {
                'idle': 'Idle',
                'homing': 'Homing',
                'moving': 'Moving',
                'positioning': 'Positioning',
                'unknown': 'Unknown'
            };
            return activityMap[activity] || activity;
        }
        
        function getActivityClass(activity) {
            switch(activity) {
                case 'idle': return 'idle';
                case 'homing':
                case 'moving':
                case 'positioning': return 'busy';
                case 'error': return 'error';
                default: return 'idle';
            }
        }
        
        function captureFromCamera(cameraId) {
            capturePhoto();
        }
        
        // Initialize Dashboard when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Dashboard page loaded, initializing...');
            
            // Check if all motion status elements exist
            const motionElements = [
                'motionConnection', 'motionHomed', 'currentX', 'currentY', 'currentZ', 'currentC', 
                'motionState', 'motionActivity', 'fluidncStatus'
            ];
            
            console.log('Checking motion status elements:');
            motionElements.forEach(id => {
                const element = document.getElementById(id);
                console.log(`${id}: ${element ? 'Found' : 'MISSING'}`);
            });
            
            // Initialize ScannerBase first
            if (window.ScannerBase) {
                console.log('Initializing ScannerBase...');
                ScannerBase.init();
            } else {
                console.warn('ScannerBase not available');
            }
            
            // Initialize Dashboard
            if (window.Dashboard) {
                console.log('Initializing Dashboard...');
                Dashboard.init();
                console.log('Dashboard initialized successfully');
            } else {
                console.warn('Dashboard.js not loaded, using fallback functions');
            }
            
            // Start camera refresh
            startCameraRefresh();
            
            // Initial status refresh after a short delay to ensure everything is loaded
            setTimeout(() => {
                console.log('Triggering initial status refresh...');
                refreshStatus();
            }, 1000);
            
            // Enable autofocus by default after page loads
            setTimeout(() => {
                triggerAutofocus();
            }, 2000); // Wait 2 seconds for camera to initialize
        });
    </script>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing...</div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/dashboard.js') }}"></script>
{% endblock %}