{% extends "base.html" %}

{% block title %}Dashboard - 3D Scanner Control{% endblock %}

{% block head %}
<style>
    .camera-controls-panel {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border: 1px solid #dee2e6;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .control-group {
        background: white;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid #e9ecef;
    }
    
    .control-group label {
        color: #495057;
        font-weight: 600;
        font-size: 0.8rem;
    }
    
    .btn {
        padding: 3px 6px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7rem;
        transition: all 0.2s;
    }
    
    .btn-primary {
        background: #007bff;
        color: white;
    }
    
    .btn-primary:hover {
        background: #0056b3;
    }
    
    .btn-secondary {
        background: #6c757d;
        color: white;
    }
    
    .btn-secondary:hover {
        background: #545b62;
    }
    
    .btn-sm {
        padding: 2px 4px;
        font-size: 0.65rem;
    }
    
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: #ddd;
        border-radius: 3px;
        outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
    }
    
    .status-info { color: #17a2b8; }
    .status-success { color: #28a745; }
    .status-error { color: #dc3545; }
</style>
{% endblock %}

{% block content %}
<div class="dashboard-grid">
    <!-- System Status Panel -->
    <section class="status-panel">
        <h2>System Status</h2>
        <div class="status-grid">
            <div class="status-item">
                <div class="status-header">
                    <span class="status-label">Motion Controller</span>
                    <span class="status-indicator" id="motionStatus">‚óè</span>
                </div>
                <div class="status-details" id="motionDetails">
                    <div>Connection: <span id="motionConnection" class="status-value">Unknown</span></div>
                    <div>Homed: <span id="motionHomed" class="status-value">Unknown</span></div>
                    <div>Position: <span id="currentPosition">X:0.0 Y:0.0 Z:0.0 C:0.0</span></div>
                    <div>State: <span id="motionState">Unknown</span></div>
                    <div>Activity: <span id="motionActivity" class="status-value">Unknown</span></div>
                    <div>FluidNC: <span id="fluidncStatus" class="status-value">Unknown</span></div>
                </div>
            </div>

            <div class="status-item">
                <div class="status-header">
                    <span class="status-label">Cameras</span>
                    <span class="status-indicator" id="cameraStatus">‚óè</span>
                </div>
                <div class="status-details" id="cameraDetails">
                    <div>Available: <span id="cameraCount">0</span></div>
                    <div>Active: <span id="activeCameras">None</span></div>
                    <div>State: <span id="cameraState">Unknown</span></div>
                </div>
            </div>

            <div class="status-item">
                <div class="status-header">
                    <span class="status-label">Lighting</span>
                    <span class="status-indicator" id="lightingStatus">‚óè</span>
                </div>
                <div class="status-details" id="lightingDetails">
                    <div>Zones: <span id="lightingZones">0</span></div>
                    <div>Status: <span id="lightingState">Unknown</span></div>
                </div>
            </div>

            <div class="status-item">
                <div class="status-header">
                    <span class="status-label">Current Scan</span>
                    <span class="status-indicator" id="scanStatus">‚óè</span>
                </div>
                <div class="status-details" id="scanDetails">
                    <div>Progress: <span id="scanProgress">---%</span></div>
                    <div>Points: <span id="scanPoints">0/0</span></div>
                    <div>Phase: <span id="scanPhase">Idle</span></div>
                    <div>State: <span id="scanState">Unknown</span></div>
                </div>
            </div>
        </div>
    </section>

    <!-- Quick Actions Panel -->
    <section class="actions-panel">
        <h2>Quick Actions</h2>
        <div class="action-grid">
            <button class="action-btn primary" onclick="homeAllAxes()" id="homeAllBtn">
                üè† Home All
            </button>
            <button class="action-btn secondary" onclick="capturePhoto()" id="captureBtn">
                üì∏ Capture Photo
            </button>
            <button class="action-btn secondary" onclick="testLighting()" id="lightTestBtn">
                ‚ö° Test Lighting
            </button>
            <button class="action-btn tertiary" onclick="window.location.href='/manual'">
                üéÆ Manual Control
            </button>
            <button class="action-btn tertiary" onclick="window.location.href='/scans'">
                üìä Start Scan
            </button>
            <button class="action-btn tertiary" onclick="refreshStatus()">
                üîÑ Refresh Status
            </button>
        </div>
    </section>

    <!-- Camera Feeds Panel -->
    <section class="camera-panel">
        <h2>Live Camera Feed</h2>
        <div class="camera-grid">
            <div class="camera-container">
                <h3 style="font-size: 0.9rem; margin-bottom: 0.5rem;">Camera 0 - Native 1080p Stream</h3>
                <div class="camera-feed-wrapper">
                    <img id="camera0Feed" 
                         src="/camera/0?t=0" 
                         alt="Camera 0 - 1080p Stream" 
                         class="camera-feed"
                         style="width: 100%; height: auto; border-radius: 8px; max-width: 600px;"
                         onload="cameraStreamWorking = true; console.log('Camera 0 native 1080p stream loaded');"
                         onerror="console.log('Camera 0 stream error, retrying...'); setTimeout(() => { const timestamp = Date.now(); this.src = '/camera/0?t=' + timestamp; }, 2000);">
                    <div class="camera-overlay">
                        <button class="camera-control" onclick="captureFromCamera(0)" style="padding: 0.3rem 0.6rem; font-size: 0.8rem;">üì∏ Capture High-Res</button>
                    </div>
                </div>
                <div class="camera-info">
                    <small style="font-size: 0.75rem;">üé• Live 1080p stream ‚Ä¢ üì∏ High-res capture available during scanning</small>
                </div>
                
                <!-- Camera Controls - Compact -->
                <div class="camera-controls-panel" style="margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="font-size: 0.9rem; margin-bottom: 0.5rem;">Camera Controls</h4>
                    <div class="controls-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <!-- Focus Controls -->
                        <div class="control-group" style="padding: 0.5rem;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.8rem;">Focus Control</label>
                            <div style="display: flex; gap: 0.3rem; margin-bottom: 0.5rem;">
                                <button class="btn btn-sm btn-primary" onclick="triggerAutofocus()" style="padding: 0.2rem 0.4rem; font-size: 0.7rem;">üéØ Auto</button>
                                <button class="btn btn-sm btn-secondary" onclick="toggleManualFocus()" style="padding: 0.2rem 0.4rem; font-size: 0.7rem;">‚öôÔ∏è Manual</button>
                                <button id="stabilizeBtn" class="btn btn-sm btn-warning" onclick="toggleStabilization()" style="padding: 0.2rem 0.4rem; font-size: 0.7rem;">üîß Stab</button>
                            </div>
                            <div id="manualFocusPanel" style="display: none;">
                                <label for="focusSlider" style="font-size: 0.7rem;">Focus Position (0=Near, 10=Far)</label>
                                <input type="range" id="focusSlider" min="0" max="10" step="0.1" value="5" 
                                       style="width: 100%;" onchange="setManualFocus(this.value)">
                                <span id="focusValue" style="font-size: 0.7rem;">5.0</span>
                            </div>
                        </div>
                        
                        <!-- Exposure Controls -->
                        <div class="control-group" style="padding: 0.5rem;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.8rem;">Exposure Control</label>
                            <div style="margin-bottom: 0.5rem;">
                                <label style="display: flex; align-items: center; font-size: 0.75rem;">
                                    <input type="checkbox" id="autoExposure" checked onchange="toggleAutoExposure(this.checked)">
                                    <span style="margin-left: 0.3rem;">Auto Exposure</span>
                                </label>
                            </div>
                            <div id="manualExposurePanel" style="display: none;">
                                <label for="exposureSlider" style="font-size: 0.7rem;">Exposure Time (ms)</label>
                                <input type="range" id="exposureSlider" min="1" max="100" value="10" 
                                       style="width: 100%;" onchange="setExposureTime(this.value)">
                                <span id="exposureValue" style="font-size: 0.7rem;">10ms</span>
                            </div>
                        </div>
                        
                        <!-- ISO Controls -->
                        <div class="control-group" style="padding: 0.5rem;">
                            <label for="isoSlider" style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.8rem;">ISO Setting</label>
                            <input type="range" id="isoSlider" min="100" max="1600" step="100" value="400" 
                                   style="width: 100%;" onchange="setISO(this.value)">
                            <span id="isoValue" style="font-size: 0.7rem;">ISO 400</span>
                        </div>
                        
                        <!-- White Balance -->
                        <div class="control-group" style="padding: 0.5rem;">
                            <label style="display: block; margin-bottom: 0.3rem; font-weight: 500; font-size: 0.8rem;">White Balance</label>
                            <div style="margin-bottom: 0.4rem;">
                                <label style="display: flex; align-items: center; font-size: 0.75rem;">
                                    <input type="checkbox" id="autoWhiteBalance" checked onchange="toggleAutoWhiteBalance(this.checked)">
                                    <span style="margin-left: 0.3rem;">Auto White Balance</span>
                                </label>
                            </div>
                            <div id="manualWhiteBalancePanel" style="display: none;">
                                <label style="font-size: 0.7rem; display: block; margin-bottom: 0.3rem;">White Balance Mode</label>
                                <select id="whiteBalanceMode" style="width: 100%; padding: 0.2rem; margin-bottom: 0.4rem; font-size: 0.7rem;" onchange="setWhiteBalanceMode(this.value)">
                                    <option value="indoor">üè† Indoor</option>
                                    <option value="daylight">‚òÄÔ∏è Daylight</option>
                                    <option value="tungsten">üí° Tungsten</option>
                                </select>
                                <button class="btn btn-sm btn-success" onclick="lockWhiteBalance()" style="width: 100%; padding: 0.2rem; font-size: 0.7rem;">
                                    üîí Lock Current WB
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Status Display -->
                    <div id="controlsStatus" style="margin-top: 0.5rem; padding: 0.4rem; background: #e9ecef; border-radius: 4px; font-size: 0.7rem;">
                        Status: Ready
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Reserved Space for Future Visual -->
    <section class="reserved-panel" style="background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); border: 2px dashed #cbd5e1; display: flex; align-items: center; justify-content: center; min-height: 200px;">
        <div style="text-align: center; color: #64748b;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìä</div>
            <div style="font-weight: 600; margin-bottom: 0.25rem;">Reserved Space</div>
            <div style="font-size: 0.8rem;">Future visualization will be placed here</div>
        </div>
    </section>

    <!-- Activity Log Panel - Full Width Bottom -->
    <section class="log-panel">
        <h2 style="font-size: 0.9rem; margin-bottom: 0.5rem;">Activity Log</h2>
        <div class="log-container" style="max-height: 120px;">
            <div id="activityLog" class="log-content" style="font-size: 0.75rem; max-height: 90px; overflow-y: auto;">
                <div class="log-entry info">
                    <span class="log-timestamp">{{ status.timestamp[:19] if status.timestamp else '--:--:--' }}</span>
                    <span class="log-message">Web interface initialized</span>
                </div>
            </div>
            <div class="log-controls" style="margin-top: 0.5rem;">
                <button onclick="clearLog()" class="log-control-btn" style="padding: 0.2rem 0.5rem; font-size: 0.7rem;">Clear</button>
                <button onclick="downloadLog()" class="log-control-btn" style="padding: 0.2rem 0.5rem; font-size: 0.7rem;">Download</button>
                <label class="log-control-checkbox" style="font-size: 0.7rem;">
                    <input type="checkbox" id="autoScroll" checked>
                    Auto-scroll
                </label>
            </div>
        </div>
    </section>

    <script>
        // High-performance camera stream management
        let cameraStreamWorking = false;
        let refreshInterval = null;
        let streamCheckInterval = null;
        
        function startCameraRefresh() {
            // Initial load with immediate refresh
            refreshCameraStream();
            
            // Reduced refresh interval for smoother streaming
            refreshInterval = setInterval(refreshCameraStream, 15000);  // Every 15 seconds
            
            // Monitor stream health
            streamCheckInterval = setInterval(checkStreamHealth, 5000);  // Every 5 seconds
        }
        
        function refreshCameraStream() {
            const camera0Feed = document.getElementById('camera0Feed');
            if (camera0Feed) {
                const timestamp = Date.now();
                console.log('Refreshing Camera 0 native 1080p stream...');
                camera0Feed.src = '/camera/0?t=' + timestamp;
            }
        }
        
        function checkStreamHealth() {
            const camera0Feed = document.getElementById('camera0Feed');
            if (camera0Feed && !cameraStreamWorking) {
                console.log('Camera stream health check - refreshing...');
                refreshCameraStream();
            }
            // Reset flag for next check
            cameraStreamWorking = false;
        }
        
        function stopCameraRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
            if (streamCheckInterval) {
                clearInterval(streamCheckInterval);
                streamCheckInterval = null;
            }
        }
        
        // Stop refresh when page unloads
        window.addEventListener('beforeunload', stopCameraRefresh);
        
        // Camera Control Functions
        async function triggerAutofocus() {
            try {
                updateControlsStatus('Triggering autofocus...', 'info');
                
                const response = await fetch('/api/camera/autofocus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ camera_id: 'camera_1' })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus('Autofocus triggered successfully', 'success');
                } else {
                    updateControlsStatus('Autofocus failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Autofocus error: ' + error.message, 'error');
                console.error('Autofocus error:', error);
            }
        }
        
        function toggleManualFocus() {
            const panel = document.getElementById('manualFocusPanel');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Disable autofocus when switching to manual
                setCameraControls({ autofocus: false });
            }
        }
        
        async function setManualFocus(position) {
            try {
                document.getElementById('focusValue').textContent = parseFloat(position).toFixed(1);
                
                const response = await fetch('/api/camera/focus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        focus_position: parseFloat(position)
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus(`Manual focus set to ${position}`, 'success');
                } else {
                    updateControlsStatus('Focus setting failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Focus setting error: ' + error.message, 'error');
                console.error('Manual focus error:', error);
            }
        }
        
        let stabilizationEnabled = false;
        async function toggleStabilization() {
            try {
                stabilizationEnabled = !stabilizationEnabled;
                const btn = document.getElementById('stabilizeBtn');
                
                const response = await fetch('/api/camera/stabilize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        enable: stabilizationEnabled
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    btn.textContent = stabilizationEnabled ? 'üîí Stabilized' : 'üîß Stabilize';
                    btn.className = stabilizationEnabled ? 'btn btn-sm btn-success' : 'btn btn-sm btn-warning';
                    updateControlsStatus(stabilizationEnabled ? 'Camera stabilization enabled' : 'Camera stabilization disabled', 'info');
                } else {
                    updateControlsStatus('Stabilization toggle failed: ' + (result.error || 'Unknown error'), 'error');
                    stabilizationEnabled = !stabilizationEnabled; // Revert on failure
                }
            } catch (error) {
                updateControlsStatus('Stabilization error: ' + error.message, 'error');
                console.error('Stabilization error:', error);
                stabilizationEnabled = !stabilizationEnabled; // Revert on failure
            }
        }
        
        function toggleAutoExposure(enabled) {
            const panel = document.getElementById('manualExposurePanel');
            panel.style.display = enabled ? 'none' : 'block';
            setCameraControls({ auto_exposure: enabled });
        }
        
        function setExposureTime(timeMs) {
            document.getElementById('exposureValue').textContent = timeMs + 'ms';
            setCameraControls({ 
                auto_exposure: false,
                exposure_time: parseInt(timeMs)
            });
        }
        
        function setISO(isoValue) {
            document.getElementById('isoValue').textContent = 'ISO ' + isoValue;
            setCameraControls({ iso: parseInt(isoValue) });
        }
        
        function toggleAutoWhiteBalance(enabled) {
            const panel = document.getElementById('manualWhiteBalancePanel');
            panel.style.display = enabled ? 'none' : 'block';
            setWhiteBalanceMode(enabled ? 'auto' : 'indoor');
        }
        
        async function setWhiteBalanceMode(mode) {
            try {
                const response = await fetch('/api/camera/white_balance', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        mode: mode
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus(`White balance set to ${mode}`, 'success');
                } else {
                    updateControlsStatus('White balance setting failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('White balance error: ' + error.message, 'error');
                console.error('White balance error:', error);
            }
        }
        
        async function lockWhiteBalance() {
            const mode = document.getElementById('whiteBalanceMode').value;
            await setWhiteBalanceMode(mode);
            updateControlsStatus(`White balance locked to ${mode} mode`, 'info');
        }
        
        function toggleAutoWhiteBalance(enabled) {
            setCameraControls({ auto_white_balance: enabled });
        }
        
        async function setCameraControls(controls) {
            try {
                updateControlsStatus('Applying camera settings...', 'info');
                
                const response = await fetch('/api/camera/controls', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        camera_id: 'camera_1',
                        controls: controls
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    updateControlsStatus('Settings applied successfully', 'success');
                } else {
                    updateControlsStatus('Settings failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                updateControlsStatus('Settings error: ' + error.message, 'error');
                console.error('Camera controls error:', error);
            }
        }
        
        function updateControlsStatus(message, type) {
            const statusElement = document.getElementById('controlsStatus');
            if (statusElement) {
                statusElement.textContent = 'Status: ' + message;
                statusElement.className = 'status-' + type;
                
                // Clear status after 3 seconds for non-error messages
                if (type !== 'error') {
                    setTimeout(() => {
                        statusElement.textContent = 'Status: Ready';
                        statusElement.className = '';
                    }, 3000);
                }
            }
        }
        
        // Motion Control Functions
        // Notification system
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 20px;
                border-radius: 5px;
                color: white;
                z-index: 10000;
                opacity: 0;
                transition: opacity 0.3s;
            `;
            
            // Set background color based on type
            if (type === 'success') notification.style.backgroundColor = '#4CAF50';
            else if (type === 'error') notification.style.backgroundColor = '#f44336';
            else if (type === 'warning') notification.style.backgroundColor = '#ff9800';
            else notification.style.backgroundColor = '#2196F3';
            
            document.body.appendChild(notification);
            
            // Fade in
            setTimeout(() => { notification.style.opacity = '1'; }, 10);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        async function homeAllAxes() {
            try {
                console.log('Homing all axes...');
                
                // Disable button during homing
                const homeButton = document.getElementById('homeAllBtn');
                if (homeButton) {
                    homeButton.disabled = true;
                    homeButton.textContent = 'Homing...';
                }
                
                showNotification('üè† Starting homing sequence...', 'info');
                
                const response = await fetch('/api/home', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ axes: ['X', 'Y', 'Z', 'C'] })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Homing started successfully');
                        if (result.status === 'in_progress') {
                            showNotification('üîÑ Homing in progress... This may take 30-60 seconds', 'warning');
                            
                            // Start monitoring homing progress
                            let checkCount = 0;
                            const maxChecks = 120; // 2 minutes max
                            
                            const checkProgress = async () => {
                                try {
                                    checkCount++;
                                    const statusResponse = await fetch('/api/status');
                                    const status = await statusResponse.json();
                                    
                                    // Check if motion controller is idle (homing complete)
                                    if (status.motion && status.motion.status === 'idle') {
                                        showNotification('‚úÖ All axes homed successfully!', 'success');
                                        await refreshStatus();
                                        
                                        // Re-enable button
                                        if (homeButton) {
                                            homeButton.disabled = false;
                                            homeButton.textContent = 'Home All Axes';
                                        }
                                        return;
                                    }
                                    
                                    // Show progress updates
                                    if (checkCount % 5 === 0) { // Every 5 seconds
                                        showNotification(`üîÑ Homing in progress... (${Math.round(checkCount/2)}s)`, 'warning');
                                    }
                                    
                                    // Continue checking if not exceeded max time
                                    if (checkCount < maxChecks) {
                                        setTimeout(checkProgress, 500); // Check every 500ms
                                    } else {
                                        showNotification('‚ö†Ô∏è Homing timeout - check system status', 'error');
                                        if (homeButton) {
                                            homeButton.disabled = false;
                                            homeButton.textContent = 'Home All Axes';
                                        }
                                    }
                                } catch (error) {
                                    console.error('Progress check error:', error);
                                    if (homeButton) {
                                        homeButton.disabled = false;
                                        homeButton.textContent = 'Home All Axes';
                                    }
                                }
                            };
                            
                            // Start progress monitoring after a short delay
                            setTimeout(checkProgress, 1000);
                        } else {
                            showNotification('‚úÖ All axes homed successfully!', 'success');
                            await refreshStatus();
                            if (homeButton) {
                                homeButton.disabled = false;
                                homeButton.textContent = 'Home All Axes';
                            }
                        }
                    } else {
                        console.error('Homing failed:', result.error);
                        showNotification('‚ùå Homing failed: ' + (result.error || 'Unknown error'), 'error');
                        if (homeButton) {
                            homeButton.disabled = false;
                            homeButton.textContent = 'Home All Axes';
                        }
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Home API error:', response.status, errorText);
                    showNotification(`‚ùå Home request failed: ${response.status}`, 'error');
                    if (homeButton) {
                        homeButton.disabled = false;
                        homeButton.textContent = 'Home All Axes';
                    }
                }
            } catch (error) {
                console.error('Homing error:', error);
                showNotification('‚ùå Homing error: ' + error.message, 'error');
                const homeButton = document.getElementById('homeAllBtn');
                if (homeButton) {
                    homeButton.disabled = false;
                    homeButton.textContent = 'Home All Axes';
                }
            }
        }
        
        async function capturePhoto() {
            try {
                console.log('Capturing photo...');
                showNotification('Capturing photo...', 'info');
                
                const response = await fetch('/api/camera/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ camera_id: 0 })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Photo captured successfully');
                        showNotification('Photo captured successfully!', 'success');
                    } else {
                        console.error('Photo capture failed:', result.error);
                        showNotification('Photo capture failed: ' + (result.error || 'Unknown error'), 'error');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Capture API error:', response.status, errorText);
                    showNotification(`Capture request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Photo capture error:', error);
                showNotification('Photo capture error: ' + error.message, 'error');
            }
        }
        
        async function testLighting() {
            try {
                console.log('Testing lighting...');
                showNotification('Testing lighting...', 'info');
                
                const response = await fetch('/api/lighting/flash', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        zone: 'all',
                        brightness: 0.5,
                        duration: 1000
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Lighting test successful');
                        showNotification('Lighting test successful!', 'success');
                    } else {
                        console.error('Lighting test failed:', result.error);
                        showNotification('Lighting test failed: ' + (result.error || 'Unknown error'), 'error');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Lighting API error:', response.status, errorText);
                    showNotification(`Lighting request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Lighting test error:', error);
                showNotification('Lighting test error: ' + error.message, 'error');
            }
        }
        
        async function refreshStatus() {
            try {
                console.log('Refreshing status...');
                const response = await fetch('/api/status');
                const status = await response.json();
                
                // Use Dashboard.js motion status update if available
                if (window.Dashboard && Dashboard.updateMotionStatus) {
                    Dashboard.updateMotionStatus(status);
                } else {
                    // Fallback to basic updates
                    updateBasicMotionStatus(status);
                }
                
                // Update camera status
                if (status.cameras) {
                    const countElement = document.getElementById('cameraCount');
                    if (countElement) {
                        countElement.textContent = status.cameras.available;
                    }
                    
                    const activeElement = document.getElementById('activeCameras');
                    if (activeElement) {
                        activeElement.textContent = status.cameras.active.join(', ') || 'None';
                    }
                    
                    const stateElement = document.getElementById('cameraState');
                    if (stateElement) {
                        stateElement.textContent = status.cameras.status;
                    }
                    
                    const statusElement = document.getElementById('cameraStatus');
                    if (statusElement) {
                        statusElement.className = 
                            'status-indicator ' + (status.cameras.available > 0 ? 'ready' : 'error');
                    }
                }
                
                // Update lighting status
                if (status.lighting) {
                    const zonesElement = document.getElementById('lightingZones');
                    if (zonesElement) {
                        zonesElement.textContent = status.lighting.zones ? status.lighting.zones.length : 0;
                    }
                    
                    const stateElement = document.getElementById('lightingState');
                    if (stateElement) {
                        stateElement.textContent = status.lighting.status;
                    }
                    
                    const statusElement = document.getElementById('lightingStatus');
                    if (statusElement) {
                        statusElement.className = 
                            'status-indicator ' + (status.lighting.zones && status.lighting.zones.length > 0 ? 'ready' : 'error');
                    }
                }
                
                console.log('Status refreshed successfully');
            } catch (error) {
                console.error('Status refresh error:', error);
            }
        }
        
        function updateBasicMotionStatus(status) {
            // Basic fallback motion status updates
            if (status.motion) {
                const posElement = document.getElementById('currentPosition');
                if (posElement) {
                    posElement.textContent = 
                        `X:${status.motion.position.x.toFixed(1)} Y:${status.motion.position.y.toFixed(1)} Z:${status.motion.position.z.toFixed(1)} C:${status.motion.position.c.toFixed(1)}`;
                }
                
                const stateElement = document.getElementById('motionState');
                if (stateElement) {
                    stateElement.textContent = status.motion.status;
                }
                
                const statusElement = document.getElementById('motionStatus');
                if (statusElement) {
                    statusElement.className = 
                        'status-indicator ' + (status.motion.connected ? 'ready' : 'error');
                }
            }
        }
        
        function captureFromCamera(cameraId) {
            capturePhoto();
        }
        
        // Initialize Dashboard when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize ScannerBase first
            if (window.ScannerBase) {
                ScannerBase.init();
            }
            
            // Initialize Dashboard
            if (window.Dashboard) {
                Dashboard.init();
                console.log('Dashboard initialized successfully');
            } else {
                console.warn('Dashboard.js not loaded, using fallback functions');
            }
            
            // Start camera refresh
            startCameraRefresh();
            
            // Enable autofocus by default after page loads
            setTimeout(() => {
                triggerAutofocus();
            }, 2000); // Wait 2 seconds for camera to initialize
        });
    </script>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing...</div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/dashboard.js') }}"></script>
{% endblock %}